// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DailyRecurrenceInitParameters struct {

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	RecurrenceRange []RecurrenceRangeInitParameters `json:"recurrenceRange,omitempty" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	TimeWindow []TimeWindowInitParameters `json:"timeWindow,omitempty" tf:"time_window,omitempty"`
}

type DailyRecurrenceObservation struct {

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	RecurrenceRange []RecurrenceRangeObservation `json:"recurrenceRange,omitempty" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	TimeWindow []TimeWindowObservation `json:"timeWindow,omitempty" tf:"time_window,omitempty"`
}

type DailyRecurrenceParameters struct {

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	// +kubebuilder:validation:Optional
	RecurrenceRange []RecurrenceRangeParameters `json:"recurrenceRange" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	// +kubebuilder:validation:Optional
	TimeWindow []TimeWindowParameters `json:"timeWindow" tf:"time_window,omitempty"`
}

type FilterInitParameters struct {

	// (String) A specific entity that should match this maintenance window.. Note: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
	// A specific entity that should match this maintenance window.. **Note**: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
	EntityID *string `json:"entityId,omitempty" tf:"entity_id,omitempty"`

	// (Set of String) Entities which contain all of the configured tags will match this maintenance window.
	// Entities which contain all of the configured tags will match this maintenance window.
	// +listType=set
	EntityTags []*string `json:"entityTags,omitempty" tf:"entity_tags,omitempty"`

	// (String) Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
	// Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
	EntityType *string `json:"entityType,omitempty" tf:"entity_type,omitempty"`

	// (Set of String) Entities which are part of all the configured management zones will match this maintenance window.
	// Entities which are part of all the configured management zones will match this maintenance window.
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`
}

type FilterObservation struct {

	// (String) A specific entity that should match this maintenance window.. Note: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
	// A specific entity that should match this maintenance window.. **Note**: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
	EntityID *string `json:"entityId,omitempty" tf:"entity_id,omitempty"`

	// (Set of String) Entities which contain all of the configured tags will match this maintenance window.
	// Entities which contain all of the configured tags will match this maintenance window.
	// +listType=set
	EntityTags []*string `json:"entityTags,omitempty" tf:"entity_tags,omitempty"`

	// (String) Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
	// Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
	EntityType *string `json:"entityType,omitempty" tf:"entity_type,omitempty"`

	// (Set of String) Entities which are part of all the configured management zones will match this maintenance window.
	// Entities which are part of all the configured management zones will match this maintenance window.
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`
}

type FilterParameters struct {

	// (String) A specific entity that should match this maintenance window.. Note: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
	// A specific entity that should match this maintenance window.. **Note**: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
	// +kubebuilder:validation:Optional
	EntityID *string `json:"entityId,omitempty" tf:"entity_id,omitempty"`

	// (Set of String) Entities which contain all of the configured tags will match this maintenance window.
	// Entities which contain all of the configured tags will match this maintenance window.
	// +kubebuilder:validation:Optional
	// +listType=set
	EntityTags []*string `json:"entityTags,omitempty" tf:"entity_tags,omitempty"`

	// (String) Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
	// Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
	// +kubebuilder:validation:Optional
	EntityType *string `json:"entityType,omitempty" tf:"entity_type,omitempty"`

	// (Set of String) Entities which are part of all the configured management zones will match this maintenance window.
	// Entities which are part of all the configured management zones will match this maintenance window.
	// +kubebuilder:validation:Optional
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`
}

type FiltersInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Filter []FilterInitParameters `json:"filter,omitempty" tf:"filter,omitempty"`
}

type FiltersObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Filter []FilterObservation `json:"filter,omitempty" tf:"filter,omitempty"`
}

type FiltersParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Filter []FilterParameters `json:"filter" tf:"filter,omitempty"`
}

type GeneralPropertiesInitParameters struct {

	// (String) A short description of the maintenance purpose.
	// A short description of the maintenance purpose.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) Disables the execution of the synthetic monitors that are within the scope of this maintenance window.
	// Disables the execution of the synthetic monitors that are within [the scope of this maintenance window](https://dt-url.net/0e0341m).
	DisableSynthetic *bool `json:"disableSynthetic,omitempty" tf:"disable_synthetic,omitempty"`

	// (String) The name of the maintenance window, displayed in the UI
	// The name of the maintenance window, displayed in the UI
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The type of suppression of alerting and problem detection during the maintenance. Possible Values: DETECT_PROBLEMS_AND_ALERT, DETECT_PROBLEMS_DONT_ALERT, DONT_DETECT_PROBLEMS
	// The type of suppression of alerting and problem detection during the maintenance. Possible Values: `DETECT_PROBLEMS_AND_ALERT`, `DETECT_PROBLEMS_DONT_ALERT`, `DONT_DETECT_PROBLEMS`
	Suppression *string `json:"suppression,omitempty" tf:"suppression,omitempty"`

	// (String) The type of the maintenance, possible values: PLANNED or UNPLANNED
	// The type of the maintenance, possible values: `PLANNED` or `UNPLANNED`
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type GeneralPropertiesObservation struct {

	// (String) A short description of the maintenance purpose.
	// A short description of the maintenance purpose.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) Disables the execution of the synthetic monitors that are within the scope of this maintenance window.
	// Disables the execution of the synthetic monitors that are within [the scope of this maintenance window](https://dt-url.net/0e0341m).
	DisableSynthetic *bool `json:"disableSynthetic,omitempty" tf:"disable_synthetic,omitempty"`

	// (String) The name of the maintenance window, displayed in the UI
	// The name of the maintenance window, displayed in the UI
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The type of suppression of alerting and problem detection during the maintenance. Possible Values: DETECT_PROBLEMS_AND_ALERT, DETECT_PROBLEMS_DONT_ALERT, DONT_DETECT_PROBLEMS
	// The type of suppression of alerting and problem detection during the maintenance. Possible Values: `DETECT_PROBLEMS_AND_ALERT`, `DETECT_PROBLEMS_DONT_ALERT`, `DONT_DETECT_PROBLEMS`
	Suppression *string `json:"suppression,omitempty" tf:"suppression,omitempty"`

	// (String) The type of the maintenance, possible values: PLANNED or UNPLANNED
	// The type of the maintenance, possible values: `PLANNED` or `UNPLANNED`
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type GeneralPropertiesParameters struct {

	// (String) A short description of the maintenance purpose.
	// A short description of the maintenance purpose.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) Disables the execution of the synthetic monitors that are within the scope of this maintenance window.
	// Disables the execution of the synthetic monitors that are within [the scope of this maintenance window](https://dt-url.net/0e0341m).
	// +kubebuilder:validation:Optional
	DisableSynthetic *bool `json:"disableSynthetic" tf:"disable_synthetic,omitempty"`

	// (String) The name of the maintenance window, displayed in the UI
	// The name of the maintenance window, displayed in the UI
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// (String) The type of suppression of alerting and problem detection during the maintenance. Possible Values: DETECT_PROBLEMS_AND_ALERT, DETECT_PROBLEMS_DONT_ALERT, DONT_DETECT_PROBLEMS
	// The type of suppression of alerting and problem detection during the maintenance. Possible Values: `DETECT_PROBLEMS_AND_ALERT`, `DETECT_PROBLEMS_DONT_ALERT`, `DONT_DETECT_PROBLEMS`
	// +kubebuilder:validation:Optional
	Suppression *string `json:"suppression" tf:"suppression,omitempty"`

	// (String) The type of the maintenance, possible values: PLANNED or UNPLANNED
	// The type of the maintenance, possible values: `PLANNED` or `UNPLANNED`
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type MaintenanceInitParameters struct {

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (Block List, Max: 1) ## Filters
	// Add filters to limit the scope of maintenance to only select matching entities. If no filter is defined, the maintenance window is valid for the whole environment. Each filter is evaluated separately (OR). (see below for nested schema)
	// ## Filters
	// Add filters to limit the scope of maintenance to only select matching entities. If no filter is defined, the maintenance window is valid for the whole environment. Each filter is evaluated separately (**OR**).
	Filters []FiltersInitParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// (Block List, Min: 1, Max: 1) The general properties of the maintenance window (see below for nested schema)
	// The general properties of the maintenance window
	GeneralProperties []GeneralPropertiesInitParameters `json:"generalProperties,omitempty" tf:"general_properties,omitempty"`

	// (String) The ID of this setting when referred to by the Config REST API V1
	// The ID of this setting when referred to by the Config REST API V1
	LegacyID *string `json:"legacyId,omitempty" tf:"legacy_id,omitempty"`

	// (Block List, Min: 1, Max: 1) The schedule of the maintenance window (see below for nested schema)
	// The schedule of the maintenance window
	Schedule []ScheduleInitParameters `json:"schedule,omitempty" tf:"schedule,omitempty"`
}

type MaintenanceObservation struct {

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (Block List, Max: 1) ## Filters
	// Add filters to limit the scope of maintenance to only select matching entities. If no filter is defined, the maintenance window is valid for the whole environment. Each filter is evaluated separately (OR). (see below for nested schema)
	// ## Filters
	// Add filters to limit the scope of maintenance to only select matching entities. If no filter is defined, the maintenance window is valid for the whole environment. Each filter is evaluated separately (**OR**).
	Filters []FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	// (Block List, Min: 1, Max: 1) The general properties of the maintenance window (see below for nested schema)
	// The general properties of the maintenance window
	GeneralProperties []GeneralPropertiesObservation `json:"generalProperties,omitempty" tf:"general_properties,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) The ID of this setting when referred to by the Config REST API V1
	// The ID of this setting when referred to by the Config REST API V1
	LegacyID *string `json:"legacyId,omitempty" tf:"legacy_id,omitempty"`

	// (Block List, Min: 1, Max: 1) The schedule of the maintenance window (see below for nested schema)
	// The schedule of the maintenance window
	Schedule []ScheduleObservation `json:"schedule,omitempty" tf:"schedule,omitempty"`
}

type MaintenanceParameters struct {

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (Block List, Max: 1) ## Filters
	// Add filters to limit the scope of maintenance to only select matching entities. If no filter is defined, the maintenance window is valid for the whole environment. Each filter is evaluated separately (OR). (see below for nested schema)
	// ## Filters
	// Add filters to limit the scope of maintenance to only select matching entities. If no filter is defined, the maintenance window is valid for the whole environment. Each filter is evaluated separately (**OR**).
	// +kubebuilder:validation:Optional
	Filters []FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// (Block List, Min: 1, Max: 1) The general properties of the maintenance window (see below for nested schema)
	// The general properties of the maintenance window
	// +kubebuilder:validation:Optional
	GeneralProperties []GeneralPropertiesParameters `json:"generalProperties,omitempty" tf:"general_properties,omitempty"`

	// (String) The ID of this setting when referred to by the Config REST API V1
	// The ID of this setting when referred to by the Config REST API V1
	// +kubebuilder:validation:Optional
	LegacyID *string `json:"legacyId,omitempty" tf:"legacy_id,omitempty"`

	// (Block List, Min: 1, Max: 1) The schedule of the maintenance window (see below for nested schema)
	// The schedule of the maintenance window
	// +kubebuilder:validation:Optional
	Schedule []ScheduleParameters `json:"schedule,omitempty" tf:"schedule,omitempty"`
}

type MonthlyRecurrenceInitParameters struct {

	// (Number) The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
	// The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
	DayOfMonth *float64 `json:"dayOfMonth,omitempty" tf:"day_of_month,omitempty"`

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	RecurrenceRange []MonthlyRecurrenceRecurrenceRangeInitParameters `json:"recurrenceRange,omitempty" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	TimeWindow []MonthlyRecurrenceTimeWindowInitParameters `json:"timeWindow,omitempty" tf:"time_window,omitempty"`
}

type MonthlyRecurrenceObservation struct {

	// (Number) The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
	// The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
	DayOfMonth *float64 `json:"dayOfMonth,omitempty" tf:"day_of_month,omitempty"`

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	RecurrenceRange []MonthlyRecurrenceRecurrenceRangeObservation `json:"recurrenceRange,omitempty" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	TimeWindow []MonthlyRecurrenceTimeWindowObservation `json:"timeWindow,omitempty" tf:"time_window,omitempty"`
}

type MonthlyRecurrenceParameters struct {

	// (Number) The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
	// The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
	// +kubebuilder:validation:Optional
	DayOfMonth *float64 `json:"dayOfMonth" tf:"day_of_month,omitempty"`

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	// +kubebuilder:validation:Optional
	RecurrenceRange []MonthlyRecurrenceRecurrenceRangeParameters `json:"recurrenceRange" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	// +kubebuilder:validation:Optional
	TimeWindow []MonthlyRecurrenceTimeWindowParameters `json:"timeWindow" tf:"time_window,omitempty"`
}

type MonthlyRecurrenceRecurrenceRangeInitParameters struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`
}

type MonthlyRecurrenceRecurrenceRangeObservation struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`
}

type MonthlyRecurrenceRecurrenceRangeParameters struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	// +kubebuilder:validation:Optional
	EndDate *string `json:"endDate" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	// +kubebuilder:validation:Optional
	StartDate *string `json:"startDate" tf:"start_date,omitempty"`
}

type MonthlyRecurrenceTimeWindowInitParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type MonthlyRecurrenceTimeWindowObservation struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type MonthlyRecurrenceTimeWindowParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	// +kubebuilder:validation:Optional
	EndTime *string `json:"endTime" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	// +kubebuilder:validation:Optional
	StartTime *string `json:"startTime" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone" tf:"time_zone,omitempty"`
}

type OnceRecurrenceInitParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type OnceRecurrenceObservation struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type OnceRecurrenceParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
	// +kubebuilder:validation:Optional
	EndTime *string `json:"endTime" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
	// +kubebuilder:validation:Optional
	StartTime *string `json:"startTime" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone" tf:"time_zone,omitempty"`
}

type RecurrenceRangeInitParameters struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`
}

type RecurrenceRangeObservation struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`
}

type RecurrenceRangeParameters struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	// +kubebuilder:validation:Optional
	EndDate *string `json:"endDate" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	// +kubebuilder:validation:Optional
	StartDate *string `json:"startDate" tf:"start_date,omitempty"`
}

type ScheduleInitParameters struct {

	// (Block List, Max: 1) The configuration for maintenance windows occuring daily (see below for nested schema)
	// The configuration for maintenance windows occuring daily
	DailyRecurrence []DailyRecurrenceInitParameters `json:"dailyRecurrence,omitempty" tf:"daily_recurrence,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring monthly (see below for nested schema)
	// The configuration for maintenance windows occuring monthly
	MonthlyRecurrence []MonthlyRecurrenceInitParameters `json:"monthlyRecurrence,omitempty" tf:"monthly_recurrence,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring once (see below for nested schema)
	// The configuration for maintenance windows occuring once
	OnceRecurrence []OnceRecurrenceInitParameters `json:"onceRecurrence,omitempty" tf:"once_recurrence,omitempty"`

	// (String) The type of the maintenance, possible values: PLANNED or UNPLANNED
	// The type maintenance window, possible values: `DAILY`, `MONTHLY`, `ONCE`, `WEEKLY`
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring weekly (see below for nested schema)
	// The configuration for maintenance windows occuring weekly
	WeeklyRecurrence []WeeklyRecurrenceInitParameters `json:"weeklyRecurrence,omitempty" tf:"weekly_recurrence,omitempty"`
}

type ScheduleObservation struct {

	// (Block List, Max: 1) The configuration for maintenance windows occuring daily (see below for nested schema)
	// The configuration for maintenance windows occuring daily
	DailyRecurrence []DailyRecurrenceObservation `json:"dailyRecurrence,omitempty" tf:"daily_recurrence,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring monthly (see below for nested schema)
	// The configuration for maintenance windows occuring monthly
	MonthlyRecurrence []MonthlyRecurrenceObservation `json:"monthlyRecurrence,omitempty" tf:"monthly_recurrence,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring once (see below for nested schema)
	// The configuration for maintenance windows occuring once
	OnceRecurrence []OnceRecurrenceObservation `json:"onceRecurrence,omitempty" tf:"once_recurrence,omitempty"`

	// (String) The type of the maintenance, possible values: PLANNED or UNPLANNED
	// The type maintenance window, possible values: `DAILY`, `MONTHLY`, `ONCE`, `WEEKLY`
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring weekly (see below for nested schema)
	// The configuration for maintenance windows occuring weekly
	WeeklyRecurrence []WeeklyRecurrenceObservation `json:"weeklyRecurrence,omitempty" tf:"weekly_recurrence,omitempty"`
}

type ScheduleParameters struct {

	// (Block List, Max: 1) The configuration for maintenance windows occuring daily (see below for nested schema)
	// The configuration for maintenance windows occuring daily
	// +kubebuilder:validation:Optional
	DailyRecurrence []DailyRecurrenceParameters `json:"dailyRecurrence,omitempty" tf:"daily_recurrence,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring monthly (see below for nested schema)
	// The configuration for maintenance windows occuring monthly
	// +kubebuilder:validation:Optional
	MonthlyRecurrence []MonthlyRecurrenceParameters `json:"monthlyRecurrence,omitempty" tf:"monthly_recurrence,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring once (see below for nested schema)
	// The configuration for maintenance windows occuring once
	// +kubebuilder:validation:Optional
	OnceRecurrence []OnceRecurrenceParameters `json:"onceRecurrence,omitempty" tf:"once_recurrence,omitempty"`

	// (String) The type of the maintenance, possible values: PLANNED or UNPLANNED
	// The type maintenance window, possible values: `DAILY`, `MONTHLY`, `ONCE`, `WEEKLY`
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// (Block List, Max: 1) The configuration for maintenance windows occuring weekly (see below for nested schema)
	// The configuration for maintenance windows occuring weekly
	// +kubebuilder:validation:Optional
	WeeklyRecurrence []WeeklyRecurrenceParameters `json:"weeklyRecurrence,omitempty" tf:"weekly_recurrence,omitempty"`
}

type TimeWindowInitParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type TimeWindowObservation struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type TimeWindowParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	// +kubebuilder:validation:Optional
	EndTime *string `json:"endTime" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	// +kubebuilder:validation:Optional
	StartTime *string `json:"startTime" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone" tf:"time_zone,omitempty"`
}

type WeeklyRecurrenceInitParameters struct {

	// (String) The day of the week for weekly maintenance, possible values: FRIDAY, MONDAY, SATURDAY, SUNDAY, THURSDAY, TUESDAY, WEDNESDAY
	// The day of the week for weekly maintenance, possible values: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
	DayOfWeek *string `json:"dayOfWeek,omitempty" tf:"day_of_week,omitempty"`

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	RecurrenceRange []WeeklyRecurrenceRecurrenceRangeInitParameters `json:"recurrenceRange,omitempty" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	TimeWindow []WeeklyRecurrenceTimeWindowInitParameters `json:"timeWindow,omitempty" tf:"time_window,omitempty"`
}

type WeeklyRecurrenceObservation struct {

	// (String) The day of the week for weekly maintenance, possible values: FRIDAY, MONDAY, SATURDAY, SUNDAY, THURSDAY, TUESDAY, WEDNESDAY
	// The day of the week for weekly maintenance, possible values: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
	DayOfWeek *string `json:"dayOfWeek,omitempty" tf:"day_of_week,omitempty"`

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	RecurrenceRange []WeeklyRecurrenceRecurrenceRangeObservation `json:"recurrenceRange,omitempty" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	TimeWindow []WeeklyRecurrenceTimeWindowObservation `json:"timeWindow,omitempty" tf:"time_window,omitempty"`
}

type WeeklyRecurrenceParameters struct {

	// (String) The day of the week for weekly maintenance, possible values: FRIDAY, MONDAY, SATURDAY, SUNDAY, THURSDAY, TUESDAY, WEDNESDAY
	// The day of the week for weekly maintenance, possible values: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
	// +kubebuilder:validation:Optional
	DayOfWeek *string `json:"dayOfWeek" tf:"day_of_week,omitempty"`

	// (Block List, Min: 1, Max: 1) The recurrence date range of the maintenance window (see below for nested schema)
	// The recurrence date range of the maintenance window
	// +kubebuilder:validation:Optional
	RecurrenceRange []WeeklyRecurrenceRecurrenceRangeParameters `json:"recurrenceRange" tf:"recurrence_range,omitempty"`

	// (Block List, Min: 1, Max: 1) The time window of the maintenance window (see below for nested schema)
	// The time window of the maintenance window
	// +kubebuilder:validation:Optional
	TimeWindow []WeeklyRecurrenceTimeWindowParameters `json:"timeWindow" tf:"time_window,omitempty"`
}

type WeeklyRecurrenceRecurrenceRangeInitParameters struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`
}

type WeeklyRecurrenceRecurrenceRangeObservation struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	StartDate *string `json:"startDate,omitempty" tf:"start_date,omitempty"`
}

type WeeklyRecurrenceRecurrenceRangeParameters struct {

	// MM-DD format
	// The end date of the recurrence range in YYYY-MM-DD format
	// +kubebuilder:validation:Optional
	EndDate *string `json:"endDate" tf:"end_date,omitempty"`

	// MM-DD format
	// The start date of the recurrence range in YYYY-MM-DD format
	// +kubebuilder:validation:Optional
	StartDate *string `json:"startDate" tf:"start_date,omitempty"`
}

type WeeklyRecurrenceTimeWindowInitParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type WeeklyRecurrenceTimeWindowObservation struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	EndTime *string `json:"endTime,omitempty" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	StartTime *string `json:"startTime,omitempty" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type WeeklyRecurrenceTimeWindowParameters struct {

	// (String) The end time of the maintenance window validity period in hh:mm:ss format
	// The end time of the maintenance window validity period in hh:mm:ss format
	// +kubebuilder:validation:Optional
	EndTime *string `json:"endTime" tf:"end_time,omitempty"`

	// (String) The start time of the maintenance window validity period in hh:mm:ss format
	// The start time of the maintenance window validity period in hh:mm:ss format
	// +kubebuilder:validation:Optional
	StartTime *string `json:"startTime" tf:"start_time,omitempty"`

	// (String) The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset UTC+01:00 format or the IANA Time Zone Database format (for example, Europe/Vienna)
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone" tf:"time_zone,omitempty"`
}

// MaintenanceSpec defines the desired state of Maintenance
type MaintenanceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MaintenanceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MaintenanceInitParameters `json:"initProvider,omitempty"`
}

// MaintenanceStatus defines the observed state of Maintenance.
type MaintenanceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MaintenanceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Maintenance is the Schema for the Maintenances API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type Maintenance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.generalProperties) || (has(self.initProvider) && has(self.initProvider.generalProperties))",message="spec.forProvider.generalProperties is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.schedule) || (has(self.initProvider) && has(self.initProvider.schedule))",message="spec.forProvider.schedule is a required parameter"
	Spec   MaintenanceSpec   `json:"spec"`
	Status MaintenanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MaintenanceList contains a list of Maintenances
type MaintenanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Maintenance `json:"items"`
}

// Repository type metadata.
var (
	Maintenance_Kind             = "Maintenance"
	Maintenance_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Maintenance_Kind}.String()
	Maintenance_KindAPIVersion   = Maintenance_Kind + "." + CRDGroupVersion.String()
	Maintenance_GroupVersionKind = CRDGroupVersion.WithKind(Maintenance_Kind)
)

func init() {
	SchemeBuilder.Register(&Maintenance{}, &MaintenanceList{})
}

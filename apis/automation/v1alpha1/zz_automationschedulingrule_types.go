// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutomationSchedulingRuleInitParameters struct {

	// (String)
	BusinessCalendar *string `json:"businessCalendar,omitempty" tf:"business_calendar,omitempty"`

	// (String) An optional description for the scheduling rule
	// An optional description for the scheduling rule
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	FixedOffset []FixedOffsetInitParameters `json:"fixedOffset,omitempty" tf:"fixed_offset,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Grouping []GroupingInitParameters `json:"grouping,omitempty" tf:"grouping,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Recurrence []RecurrenceInitParameters `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	RelativeOffset []RelativeOffsetInitParameters `json:"relativeOffset,omitempty" tf:"relative_offset,omitempty"`

	// (String) The title / name of the scheduling rule
	// The title / name of the scheduling rule
	Title *string `json:"title,omitempty" tf:"title,omitempty"`
}

type AutomationSchedulingRuleObservation struct {

	// (String)
	BusinessCalendar *string `json:"businessCalendar,omitempty" tf:"business_calendar,omitempty"`

	// (String) An optional description for the scheduling rule
	// An optional description for the scheduling rule
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	FixedOffset []FixedOffsetObservation `json:"fixedOffset,omitempty" tf:"fixed_offset,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Grouping []GroupingObservation `json:"grouping,omitempty" tf:"grouping,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Recurrence []RecurrenceObservation `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	RelativeOffset []RelativeOffsetObservation `json:"relativeOffset,omitempty" tf:"relative_offset,omitempty"`

	// (String) The title / name of the scheduling rule
	// The title / name of the scheduling rule
	Title *string `json:"title,omitempty" tf:"title,omitempty"`
}

type AutomationSchedulingRuleParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	BusinessCalendar *string `json:"businessCalendar,omitempty" tf:"business_calendar,omitempty"`

	// (String) An optional description for the scheduling rule
	// An optional description for the scheduling rule
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	FixedOffset []FixedOffsetParameters `json:"fixedOffset,omitempty" tf:"fixed_offset,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Grouping []GroupingParameters `json:"grouping,omitempty" tf:"grouping,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Recurrence []RecurrenceParameters `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	RelativeOffset []RelativeOffsetParameters `json:"relativeOffset,omitempty" tf:"relative_offset,omitempty"`

	// (String) The title / name of the scheduling rule
	// The title / name of the scheduling rule
	// +kubebuilder:validation:Optional
	Title *string `json:"title,omitempty" tf:"title,omitempty"`
}

type FixedOffsetInitParameters struct {

	// (Number) Every day of the scheduling rule referred to with rule will be offset by this amount of days
	// Every day of the scheduling rule referred to with `rule` will be offset by this amount of days
	Offset *float64 `json:"offset,omitempty" tf:"offset,omitempty"`

	// (String) Refers to a scheduling rule for which to produce valid days with an offset
	// Refers to a scheduling rule for which to produce valid days with an offset
	Rule *string `json:"rule,omitempty" tf:"rule,omitempty"`
}

type FixedOffsetObservation struct {

	// (Number) Every day of the scheduling rule referred to with rule will be offset by this amount of days
	// Every day of the scheduling rule referred to with `rule` will be offset by this amount of days
	Offset *float64 `json:"offset,omitempty" tf:"offset,omitempty"`

	// (String) Refers to a scheduling rule for which to produce valid days with an offset
	// Refers to a scheduling rule for which to produce valid days with an offset
	Rule *string `json:"rule,omitempty" tf:"rule,omitempty"`
}

type FixedOffsetParameters struct {

	// (Number) Every day of the scheduling rule referred to with rule will be offset by this amount of days
	// Every day of the scheduling rule referred to with `rule` will be offset by this amount of days
	// +kubebuilder:validation:Optional
	Offset *float64 `json:"offset" tf:"offset,omitempty"`

	// (String) Refers to a scheduling rule for which to produce valid days with an offset
	// Refers to a scheduling rule for which to produce valid days with an offset
	// +kubebuilder:validation:Optional
	Rule *string `json:"rule" tf:"rule,omitempty"`
}

type GroupingInitParameters struct {

	// (Set of String) The IDs of scheduling rules determining the days the schedule should apply to
	// The IDs of scheduling rules determining the days the schedule should apply to
	// +listType=set
	Combine []*string `json:"combine,omitempty" tf:"combine,omitempty"`

	// (Set of String) The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by combine and intersect are valid days for the schedule
	// The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by `combine` and `intersect` are valid days for the schedule
	// +listType=set
	Intersect []*string `json:"intersect,omitempty" tf:"intersect,omitempty"`

	// (Set of String) The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by combine and intersect
	// The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by `combine` and `intersect`
	// +listType=set
	Subtract []*string `json:"subtract,omitempty" tf:"subtract,omitempty"`
}

type GroupingObservation struct {

	// (Set of String) The IDs of scheduling rules determining the days the schedule should apply to
	// The IDs of scheduling rules determining the days the schedule should apply to
	// +listType=set
	Combine []*string `json:"combine,omitempty" tf:"combine,omitempty"`

	// (Set of String) The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by combine and intersect are valid days for the schedule
	// The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by `combine` and `intersect` are valid days for the schedule
	// +listType=set
	Intersect []*string `json:"intersect,omitempty" tf:"intersect,omitempty"`

	// (Set of String) The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by combine and intersect
	// The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by `combine` and `intersect`
	// +listType=set
	Subtract []*string `json:"subtract,omitempty" tf:"subtract,omitempty"`
}

type GroupingParameters struct {

	// (Set of String) The IDs of scheduling rules determining the days the schedule should apply to
	// The IDs of scheduling rules determining the days the schedule should apply to
	// +kubebuilder:validation:Optional
	// +listType=set
	Combine []*string `json:"combine" tf:"combine,omitempty"`

	// (Set of String) The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by combine and intersect are valid days for the schedule
	// The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by `combine` and `intersect` are valid days for the schedule
	// +kubebuilder:validation:Optional
	// +listType=set
	Intersect []*string `json:"intersect,omitempty" tf:"intersect,omitempty"`

	// (Set of String) The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by combine and intersect
	// The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by `combine` and `intersect`
	// +kubebuilder:validation:Optional
	// +listType=set
	Subtract []*string `json:"subtract,omitempty" tf:"subtract,omitempty"`
}

type RecurrenceInitParameters struct {

	// 07-04 represents July 4th 2017
	// The recurrence start. Example: `2017-07-04` represents July 4th 2017
	Datestart *string `json:"datestart,omitempty" tf:"datestart,omitempty"`

	// 1 refers to the last day, -2 refers to the second to the last day, ...
	// Restricts the recurrence to specific days within a month. `1`, `2`, `3`, ... refers to the first, second, third day in the month. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
	// +listType=set
	DaysInMonth []*float64 `json:"daysInMonth,omitempty" tf:"days_in_month,omitempty"`

	// 1 refers to the last day, -2 refers to the second to the last day, ...
	// Restricts the recurrence to specific days within a year. `1`, `2`, `3`, ... refers to the first, second, third day of the year. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
	// +listType=set
	DaysInYear []*float64 `json:"daysInYear,omitempty" tf:"days_in_year,omitempty"`

	// (Set of Number) Restricts the recurrence to specific days relative to Easter Sunday. 0 will yield the Easter Sunday itself
	// Restricts the recurrence to specific days relative to Easter Sunday. `0` will yield the Easter Sunday itself
	// +listType=set
	Easter []*float64 `json:"easter,omitempty" tf:"easter,omitempty"`

	// (String) Possible values are YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY and SECONDLY. Example: frequency = DAILY and interval = 2 schedules for every other day
	// Possible values are `YEARLY`, `MONTHLY`, `WEEKLY`, `DAILY`, `HOURLY`, `MINUTELY` and `SECONDLY`. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
	Frequency *string `json:"frequency,omitempty" tf:"frequency,omitempty"`

	// (Number) The interval between each iteration. Default: 1. Example: frequency = DAILY and interval = 2 schedules for every other day
	// The interval between each iteration. Default: 1. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// (Set of Number) Restricts the recurrence to specific months. 1 for January, 2 for February, ..., 12 for December
	// Restricts the recurrence to specific months. `1` for `January`, `2` for `February`, ..., `12` for `December`
	// +listType=set
	Months []*float64 `json:"months,omitempty" tf:"months,omitempty"`

	// (Set of String) Restricts the recurrence to specific week days. Possible values are MO, TU, WE, TH, FR, SA and SU
	// Restricts the recurrence to specific week days. Possible values are `MO`, `TU`, `WE`, `TH`, `FR`, `SA` and `SU`
	// +listType=set
	Weekdays []*string `json:"weekdays,omitempty" tf:"weekdays,omitempty"`

	// 1 refers to the last week, -2 refers to the second to the last week, ...
	// Restricts the recurrence to specific weeks within a year. `1`, `2`, `3`, ... refers to the first, second, third week of the year. You can also specify negative values to refer to values relative to the last week. `-1` refers to the last week, `-2` refers to the second to the last week, ...
	// +listType=set
	Weeks []*float64 `json:"weeks,omitempty" tf:"weeks,omitempty"`

	// (String) Possible values are WORKING (Work days), HOLIDAYS (Holidays) and OFF (Weekends + Holidays)
	// Possible values are `WORKING` (Work days), `HOLIDAYS` (Holidays) and `OFF` (Weekends + Holidays)
	Workdays *string `json:"workdays,omitempty" tf:"workdays,omitempty"`
}

type RecurrenceObservation struct {

	// 07-04 represents July 4th 2017
	// The recurrence start. Example: `2017-07-04` represents July 4th 2017
	Datestart *string `json:"datestart,omitempty" tf:"datestart,omitempty"`

	// 1 refers to the last day, -2 refers to the second to the last day, ...
	// Restricts the recurrence to specific days within a month. `1`, `2`, `3`, ... refers to the first, second, third day in the month. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
	// +listType=set
	DaysInMonth []*float64 `json:"daysInMonth,omitempty" tf:"days_in_month,omitempty"`

	// 1 refers to the last day, -2 refers to the second to the last day, ...
	// Restricts the recurrence to specific days within a year. `1`, `2`, `3`, ... refers to the first, second, third day of the year. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
	// +listType=set
	DaysInYear []*float64 `json:"daysInYear,omitempty" tf:"days_in_year,omitempty"`

	// (Set of Number) Restricts the recurrence to specific days relative to Easter Sunday. 0 will yield the Easter Sunday itself
	// Restricts the recurrence to specific days relative to Easter Sunday. `0` will yield the Easter Sunday itself
	// +listType=set
	Easter []*float64 `json:"easter,omitempty" tf:"easter,omitempty"`

	// (String) Possible values are YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY and SECONDLY. Example: frequency = DAILY and interval = 2 schedules for every other day
	// Possible values are `YEARLY`, `MONTHLY`, `WEEKLY`, `DAILY`, `HOURLY`, `MINUTELY` and `SECONDLY`. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
	Frequency *string `json:"frequency,omitempty" tf:"frequency,omitempty"`

	// (Number) The interval between each iteration. Default: 1. Example: frequency = DAILY and interval = 2 schedules for every other day
	// The interval between each iteration. Default: 1. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// (Set of Number) Restricts the recurrence to specific months. 1 for January, 2 for February, ..., 12 for December
	// Restricts the recurrence to specific months. `1` for `January`, `2` for `February`, ..., `12` for `December`
	// +listType=set
	Months []*float64 `json:"months,omitempty" tf:"months,omitempty"`

	// (Set of String) Restricts the recurrence to specific week days. Possible values are MO, TU, WE, TH, FR, SA and SU
	// Restricts the recurrence to specific week days. Possible values are `MO`, `TU`, `WE`, `TH`, `FR`, `SA` and `SU`
	// +listType=set
	Weekdays []*string `json:"weekdays,omitempty" tf:"weekdays,omitempty"`

	// 1 refers to the last week, -2 refers to the second to the last week, ...
	// Restricts the recurrence to specific weeks within a year. `1`, `2`, `3`, ... refers to the first, second, third week of the year. You can also specify negative values to refer to values relative to the last week. `-1` refers to the last week, `-2` refers to the second to the last week, ...
	// +listType=set
	Weeks []*float64 `json:"weeks,omitempty" tf:"weeks,omitempty"`

	// (String) Possible values are WORKING (Work days), HOLIDAYS (Holidays) and OFF (Weekends + Holidays)
	// Possible values are `WORKING` (Work days), `HOLIDAYS` (Holidays) and `OFF` (Weekends + Holidays)
	Workdays *string `json:"workdays,omitempty" tf:"workdays,omitempty"`
}

type RecurrenceParameters struct {

	// 07-04 represents July 4th 2017
	// The recurrence start. Example: `2017-07-04` represents July 4th 2017
	// +kubebuilder:validation:Optional
	Datestart *string `json:"datestart" tf:"datestart,omitempty"`

	// 1 refers to the last day, -2 refers to the second to the last day, ...
	// Restricts the recurrence to specific days within a month. `1`, `2`, `3`, ... refers to the first, second, third day in the month. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
	// +kubebuilder:validation:Optional
	// +listType=set
	DaysInMonth []*float64 `json:"daysInMonth,omitempty" tf:"days_in_month,omitempty"`

	// 1 refers to the last day, -2 refers to the second to the last day, ...
	// Restricts the recurrence to specific days within a year. `1`, `2`, `3`, ... refers to the first, second, third day of the year. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
	// +kubebuilder:validation:Optional
	// +listType=set
	DaysInYear []*float64 `json:"daysInYear,omitempty" tf:"days_in_year,omitempty"`

	// (Set of Number) Restricts the recurrence to specific days relative to Easter Sunday. 0 will yield the Easter Sunday itself
	// Restricts the recurrence to specific days relative to Easter Sunday. `0` will yield the Easter Sunday itself
	// +kubebuilder:validation:Optional
	// +listType=set
	Easter []*float64 `json:"easter,omitempty" tf:"easter,omitempty"`

	// (String) Possible values are YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY and SECONDLY. Example: frequency = DAILY and interval = 2 schedules for every other day
	// Possible values are `YEARLY`, `MONTHLY`, `WEEKLY`, `DAILY`, `HOURLY`, `MINUTELY` and `SECONDLY`. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
	// +kubebuilder:validation:Optional
	Frequency *string `json:"frequency" tf:"frequency,omitempty"`

	// (Number) The interval between each iteration. Default: 1. Example: frequency = DAILY and interval = 2 schedules for every other day
	// The interval between each iteration. Default: 1. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// (Set of Number) Restricts the recurrence to specific months. 1 for January, 2 for February, ..., 12 for December
	// Restricts the recurrence to specific months. `1` for `January`, `2` for `February`, ..., `12` for `December`
	// +kubebuilder:validation:Optional
	// +listType=set
	Months []*float64 `json:"months,omitempty" tf:"months,omitempty"`

	// (Set of String) Restricts the recurrence to specific week days. Possible values are MO, TU, WE, TH, FR, SA and SU
	// Restricts the recurrence to specific week days. Possible values are `MO`, `TU`, `WE`, `TH`, `FR`, `SA` and `SU`
	// +kubebuilder:validation:Optional
	// +listType=set
	Weekdays []*string `json:"weekdays,omitempty" tf:"weekdays,omitempty"`

	// 1 refers to the last week, -2 refers to the second to the last week, ...
	// Restricts the recurrence to specific weeks within a year. `1`, `2`, `3`, ... refers to the first, second, third week of the year. You can also specify negative values to refer to values relative to the last week. `-1` refers to the last week, `-2` refers to the second to the last week, ...
	// +kubebuilder:validation:Optional
	// +listType=set
	Weeks []*float64 `json:"weeks,omitempty" tf:"weeks,omitempty"`

	// (String) Possible values are WORKING (Work days), HOLIDAYS (Holidays) and OFF (Weekends + Holidays)
	// Possible values are `WORKING` (Work days), `HOLIDAYS` (Holidays) and `OFF` (Weekends + Holidays)
	// +kubebuilder:validation:Optional
	Workdays *string `json:"workdays" tf:"workdays,omitempty"`
}

type RelativeOffsetInitParameters struct {

	// (String)
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (String)
	SourceRule *string `json:"sourceRule,omitempty" tf:"source_rule,omitempty"`

	// (String)
	TargetRule *string `json:"targetRule,omitempty" tf:"target_rule,omitempty"`
}

type RelativeOffsetObservation struct {

	// (String)
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (String)
	SourceRule *string `json:"sourceRule,omitempty" tf:"source_rule,omitempty"`

	// (String)
	TargetRule *string `json:"targetRule,omitempty" tf:"target_rule,omitempty"`
}

type RelativeOffsetParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Direction *string `json:"direction" tf:"direction,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	SourceRule *string `json:"sourceRule" tf:"source_rule,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	TargetRule *string `json:"targetRule" tf:"target_rule,omitempty"`
}

// AutomationSchedulingRuleSpec defines the desired state of AutomationSchedulingRule
type AutomationSchedulingRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AutomationSchedulingRuleParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AutomationSchedulingRuleInitParameters `json:"initProvider,omitempty"`
}

// AutomationSchedulingRuleStatus defines the observed state of AutomationSchedulingRule.
type AutomationSchedulingRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AutomationSchedulingRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// AutomationSchedulingRule is the Schema for the AutomationSchedulingRules API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type AutomationSchedulingRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.title) || (has(self.initProvider) && has(self.initProvider.title))",message="spec.forProvider.title is a required parameter"
	Spec   AutomationSchedulingRuleSpec   `json:"spec"`
	Status AutomationSchedulingRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AutomationSchedulingRuleList contains a list of AutomationSchedulingRules
type AutomationSchedulingRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AutomationSchedulingRule `json:"items"`
}

// Repository type metadata.
var (
	AutomationSchedulingRule_Kind             = "AutomationSchedulingRule"
	AutomationSchedulingRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AutomationSchedulingRule_Kind}.String()
	AutomationSchedulingRule_KindAPIVersion   = AutomationSchedulingRule_Kind + "." + CRDGroupVersion.String()
	AutomationSchedulingRule_GroupVersionKind = CRDGroupVersion.WithKind(AutomationSchedulingRule_Kind)
)

func init() {
	SchemeBuilder.Register(&AutomationSchedulingRule{}, &AutomationSchedulingRuleList{})
}

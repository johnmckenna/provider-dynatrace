// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DeclarativeGroupingInitParameters struct {

	// (Block List, Max: 1) Enter a descriptive process group display name and a unique identifier that Dynatrace can use to recognize this process group. (see below for nested schema)
	// Enter a descriptive process group display name and a unique identifier that Dynatrace can use to recognize this process group.
	Detection []DetectionInitParameters `json:"detection,omitempty" tf:"detection,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (String) Monitored technology name
	// Monitored technology name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type DeclarativeGroupingObservation struct {

	// (Block List, Max: 1) Enter a descriptive process group display name and a unique identifier that Dynatrace can use to recognize this process group. (see below for nested schema)
	// Enter a descriptive process group display name and a unique identifier that Dynatrace can use to recognize this process group.
	Detection []DetectionObservation `json:"detection,omitempty" tf:"detection,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (String) Monitored technology name
	// Monitored technology name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type DeclarativeGroupingParameters struct {

	// (Block List, Max: 1) Enter a descriptive process group display name and a unique identifier that Dynatrace can use to recognize this process group. (see below for nested schema)
	// Enter a descriptive process group display name and a unique identifier that Dynatrace can use to recognize this process group.
	// +kubebuilder:validation:Optional
	Detection []DetectionParameters `json:"detection,omitempty" tf:"detection,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (String) Monitored technology name
	// Monitored technology name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type DetectionInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	ProcessDefinition []ProcessDefinitionInitParameters `json:"processDefinition,omitempty" tf:"process_definition,omitempty"`
}

type DetectionObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	ProcessDefinition []ProcessDefinitionObservation `json:"processDefinition,omitempty" tf:"process_definition,omitempty"`
}

type DetectionParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	ProcessDefinition []ProcessDefinitionParameters `json:"processDefinition" tf:"process_definition,omitempty"`
}

type ProcessDefinitionInitParameters struct {

	// (String) The ID of this resource.
	// Process group identifier
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) This identifier is used by Dynatrace to recognize this process group.
	// This identifier is used by Dynatrace to recognize this process group.
	ProcessGroupName *string `json:"processGroupName,omitempty" tf:"process_group_name,omitempty"`

	// (String) Possible Values: never, always, highResourceUsage
	// Possible Values: `never`, `always`, `highResourceUsage`
	Report *string `json:"report,omitempty" tf:"report,omitempty"`

	// (Block List, Max: 1) Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it. (see below for nested schema)
	// Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it.
	Rules []RulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type ProcessDefinitionObservation struct {

	// (String) The ID of this resource.
	// Process group identifier
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) This identifier is used by Dynatrace to recognize this process group.
	// This identifier is used by Dynatrace to recognize this process group.
	ProcessGroupName *string `json:"processGroupName,omitempty" tf:"process_group_name,omitempty"`

	// (String) Possible Values: never, always, highResourceUsage
	// Possible Values: `never`, `always`, `highResourceUsage`
	Report *string `json:"report,omitempty" tf:"report,omitempty"`

	// (Block List, Max: 1) Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it. (see below for nested schema)
	// Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it.
	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`
}

type ProcessDefinitionParameters struct {

	// (String) The ID of this resource.
	// Process group identifier
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`

	// (String) This identifier is used by Dynatrace to recognize this process group.
	// This identifier is used by Dynatrace to recognize this process group.
	// +kubebuilder:validation:Optional
	ProcessGroupName *string `json:"processGroupName" tf:"process_group_name,omitempty"`

	// (String) Possible Values: never, always, highResourceUsage
	// Possible Values: `never`, `always`, `highResourceUsage`
	// +kubebuilder:validation:Optional
	Report *string `json:"report" tf:"report,omitempty"`

	// (Block List, Max: 1) Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it. (see below for nested schema)
	// Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it.
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type RuleInitParameters struct {

	// $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
	// - $prefix(svc) – Matches if app matches the prefix of the process property value.
	// - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
	//
	// For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
	//
	// For more details, see [Declarative process grouping](https://dt-url.net/j142w57).
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (String) Possible Values: Executable, ExecutablePath, CommandLine
	// Possible Values: `Executable`, `ExecutablePath`, `CommandLine`
	Property *string `json:"property,omitempty" tf:"property,omitempty"`
}

type RuleObservation struct {

	// $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
	// - $prefix(svc) – Matches if app matches the prefix of the process property value.
	// - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
	//
	// For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
	//
	// For more details, see [Declarative process grouping](https://dt-url.net/j142w57).
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (String) Possible Values: Executable, ExecutablePath, CommandLine
	// Possible Values: `Executable`, `ExecutablePath`, `CommandLine`
	Property *string `json:"property,omitempty" tf:"property,omitempty"`
}

type RuleParameters struct {

	// $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
	// - $prefix(svc) – Matches if app matches the prefix of the process property value.
	// - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
	//
	// For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
	//
	// For more details, see [Declarative process grouping](https://dt-url.net/j142w57).
	// +kubebuilder:validation:Optional
	Condition *string `json:"condition" tf:"condition,omitempty"`

	// (String) Possible Values: Executable, ExecutablePath, CommandLine
	// Possible Values: `Executable`, `ExecutablePath`, `CommandLine`
	// +kubebuilder:validation:Optional
	Property *string `json:"property" tf:"property,omitempty"`
}

type RulesInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Rule []RuleInitParameters `json:"rule,omitempty" tf:"rule,omitempty"`
}

type RulesObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Rule []RuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`
}

type RulesParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule" tf:"rule,omitempty"`
}

// DeclarativeGroupingSpec defines the desired state of DeclarativeGrouping
type DeclarativeGroupingSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DeclarativeGroupingParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DeclarativeGroupingInitParameters `json:"initProvider,omitempty"`
}

// DeclarativeGroupingStatus defines the observed state of DeclarativeGrouping.
type DeclarativeGroupingStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DeclarativeGroupingObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// DeclarativeGrouping is the Schema for the DeclarativeGroupings API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type DeclarativeGrouping struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   DeclarativeGroupingSpec   `json:"spec"`
	Status DeclarativeGroupingStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DeclarativeGroupingList contains a list of DeclarativeGroupings
type DeclarativeGroupingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DeclarativeGrouping `json:"items"`
}

// Repository type metadata.
var (
	DeclarativeGrouping_Kind             = "DeclarativeGrouping"
	DeclarativeGrouping_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DeclarativeGrouping_Kind}.String()
	DeclarativeGrouping_KindAPIVersion   = DeclarativeGrouping_Kind + "." + CRDGroupVersion.String()
	DeclarativeGrouping_GroupVersionKind = CRDGroupVersion.WithKind(DeclarativeGrouping_Kind)
)

func init() {
	SchemeBuilder.Register(&DeclarativeGrouping{}, &DeclarativeGroupingList{})
}

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationIDInitParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ServiceIDContributorInitParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ApplicationIDObservation struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ServiceIDContributorObservation `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ApplicationIDParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	// +kubebuilder:validation:Optional
	EnableIDContributor *bool `json:"enableIdContributor" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	// +kubebuilder:validation:Optional
	ServiceIDContributor []ServiceIDContributorParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ConditionsConditionInitParameters struct {

	// (String) Take the value of this attribute
	// Take the value of this attribute
	Attribute *string `json:"attribute,omitempty" tf:"attribute,omitempty"`

	// (String) Apply this operation
	// Apply this operation
	CompareOperationType *string `json:"compareOperationType,omitempty" tf:"compare_operation_type,omitempty"`

	// (Set of String) Technology
	// Technology
	// +listType=set
	Framework []*string `json:"framework,omitempty" tf:"framework,omitempty"`

	// (String) From
	// From
	IPRangeFrom *string `json:"ipRangeFrom,omitempty" tf:"ip_range_from,omitempty"`

	// (String) To
	// To
	IPRangeTo *string `json:"ipRangeTo,omitempty" tf:"ip_range_to,omitempty"`

	// (Boolean) Ignore case sensitivity for texts.
	// Ignore case sensitivity for texts.
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// (Number) Value
	// Value
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (Set of Number) Values
	// Values
	// +listType=set
	IntValues []*float64 `json:"intValues,omitempty" tf:"int_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TagValues []*string `json:"tagValues,omitempty" tf:"tag_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TextValues []*string `json:"textValues,omitempty" tf:"text_values,omitempty"`
}

type ConditionsConditionObservation struct {

	// (String) Take the value of this attribute
	// Take the value of this attribute
	Attribute *string `json:"attribute,omitempty" tf:"attribute,omitempty"`

	// (String) Apply this operation
	// Apply this operation
	CompareOperationType *string `json:"compareOperationType,omitempty" tf:"compare_operation_type,omitempty"`

	// (Set of String) Technology
	// Technology
	// +listType=set
	Framework []*string `json:"framework,omitempty" tf:"framework,omitempty"`

	// (String) From
	// From
	IPRangeFrom *string `json:"ipRangeFrom,omitempty" tf:"ip_range_from,omitempty"`

	// (String) To
	// To
	IPRangeTo *string `json:"ipRangeTo,omitempty" tf:"ip_range_to,omitempty"`

	// (Boolean) Ignore case sensitivity for texts.
	// Ignore case sensitivity for texts.
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// (Number) Value
	// Value
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (Set of Number) Values
	// Values
	// +listType=set
	IntValues []*float64 `json:"intValues,omitempty" tf:"int_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TagValues []*string `json:"tagValues,omitempty" tf:"tag_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TextValues []*string `json:"textValues,omitempty" tf:"text_values,omitempty"`
}

type ConditionsConditionParameters struct {

	// (String) Take the value of this attribute
	// Take the value of this attribute
	// +kubebuilder:validation:Optional
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// (String) Apply this operation
	// Apply this operation
	// +kubebuilder:validation:Optional
	CompareOperationType *string `json:"compareOperationType" tf:"compare_operation_type,omitempty"`

	// (Set of String) Technology
	// Technology
	// +kubebuilder:validation:Optional
	// +listType=set
	Framework []*string `json:"framework,omitempty" tf:"framework,omitempty"`

	// (String) From
	// From
	// +kubebuilder:validation:Optional
	IPRangeFrom *string `json:"ipRangeFrom,omitempty" tf:"ip_range_from,omitempty"`

	// (String) To
	// To
	// +kubebuilder:validation:Optional
	IPRangeTo *string `json:"ipRangeTo,omitempty" tf:"ip_range_to,omitempty"`

	// (Boolean) Ignore case sensitivity for texts.
	// Ignore case sensitivity for texts.
	// +kubebuilder:validation:Optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// (Number) Value
	// Value
	// +kubebuilder:validation:Optional
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (Set of Number) Values
	// Values
	// +kubebuilder:validation:Optional
	// +listType=set
	IntValues []*float64 `json:"intValues,omitempty" tf:"int_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +kubebuilder:validation:Optional
	// +listType=set
	TagValues []*string `json:"tagValues,omitempty" tf:"tag_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +kubebuilder:validation:Optional
	// +listType=set
	TextValues []*string `json:"textValues,omitempty" tf:"text_values,omitempty"`
}

type ConditionsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Condition []ConditionsConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`
}

type ConditionsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Condition []ConditionsConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`
}

type ConditionsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Condition []ConditionsConditionParameters `json:"condition" tf:"condition,omitempty"`
}

type ContextRootInitParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ContextRootServiceIDContributorInitParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ContextRootObservation struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ContextRootServiceIDContributorObservation `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ContextRootParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	// +kubebuilder:validation:Optional
	EnableIDContributor *bool `json:"enableIdContributor" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	// +kubebuilder:validation:Optional
	ServiceIDContributor []ContextRootServiceIDContributorParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ContextRootServiceIDContributorInitParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Number) How many segments should be taken.
	// The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ServiceIDContributorTransformationsInitParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ServiceIDContributorValueOverrideInitParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ContextRootServiceIDContributorObservation struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Number) How many segments should be taken.
	// The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ServiceIDContributorTransformationsObservation `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ServiceIDContributorValueOverrideObservation `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ContextRootServiceIDContributorParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
	// +kubebuilder:validation:Optional
	ContributionType *string `json:"contributionType" tf:"contribution_type,omitempty"`

	// (Number) How many segments should be taken.
	// The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
	// +kubebuilder:validation:Optional
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	// +kubebuilder:validation:Optional
	Transformations []ServiceIDContributorTransformationsParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	// +kubebuilder:validation:Optional
	ValueOverride []ServiceIDContributorValueOverrideParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type IDContributorsInitParameters struct {

	// (Block List, Min: 1, Max: 1) Application identifier (see below for nested schema)
	// Application identifier
	ApplicationID []ApplicationIDInitParameters `json:"applicationId,omitempty" tf:"application_id,omitempty"`

	// (Block List, Min: 1, Max: 1) URL context root (see below for nested schema)
	// URL context root
	ContextRoot []ContextRootInitParameters `json:"contextRoot,omitempty" tf:"context_root,omitempty"`

	// (Boolean) Let the port contribute to the Service Id
	// Let the port contribute to the Service Id
	PortForServiceID *bool `json:"portForServiceId,omitempty" tf:"port_for_service_id,omitempty"`

	// (Block List, Min: 1, Max: 1) Public domain name (see below for nested schema)
	// Public domain name
	PublicDomainName []PublicDomainNameInitParameters `json:"publicDomainName,omitempty" tf:"public_domain_name,omitempty"`
}

type IDContributorsObservation struct {

	// (Block List, Min: 1, Max: 1) Application identifier (see below for nested schema)
	// Application identifier
	ApplicationID []ApplicationIDObservation `json:"applicationId,omitempty" tf:"application_id,omitempty"`

	// (Block List, Min: 1, Max: 1) URL context root (see below for nested schema)
	// URL context root
	ContextRoot []ContextRootObservation `json:"contextRoot,omitempty" tf:"context_root,omitempty"`

	// (Boolean) Let the port contribute to the Service Id
	// Let the port contribute to the Service Id
	PortForServiceID *bool `json:"portForServiceId,omitempty" tf:"port_for_service_id,omitempty"`

	// (Block List, Min: 1, Max: 1) Public domain name (see below for nested schema)
	// Public domain name
	PublicDomainName []PublicDomainNameObservation `json:"publicDomainName,omitempty" tf:"public_domain_name,omitempty"`
}

type IDContributorsParameters struct {

	// (Block List, Min: 1, Max: 1) Application identifier (see below for nested schema)
	// Application identifier
	// +kubebuilder:validation:Optional
	ApplicationID []ApplicationIDParameters `json:"applicationId" tf:"application_id,omitempty"`

	// (Block List, Min: 1, Max: 1) URL context root (see below for nested schema)
	// URL context root
	// +kubebuilder:validation:Optional
	ContextRoot []ContextRootParameters `json:"contextRoot" tf:"context_root,omitempty"`

	// (Boolean) Let the port contribute to the Service Id
	// Let the port contribute to the Service Id
	// +kubebuilder:validation:Optional
	PortForServiceID *bool `json:"portForServiceId" tf:"port_for_service_id,omitempty"`

	// (Block List, Min: 1, Max: 1) Public domain name (see below for nested schema)
	// Public domain name
	// +kubebuilder:validation:Optional
	PublicDomainName []PublicDomainNameParameters `json:"publicDomainName" tf:"public_domain_name,omitempty"`
}

type PublicDomainNameInitParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []PublicDomainNameServiceIDContributorInitParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type PublicDomainNameObservation struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []PublicDomainNameServiceIDContributorObservation `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type PublicDomainNameParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	// +kubebuilder:validation:Optional
	EnableIDContributor *bool `json:"enableIdContributor" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	// +kubebuilder:validation:Optional
	ServiceIDContributor []PublicDomainNameServiceIDContributorParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type PublicDomainNameServiceIDContributorInitParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Boolean) Use the detected host name instead of the request's domain name.
	// Use the detected host name instead of the request's domain name.
	CopyFromHostName *bool `json:"copyFromHostName,omitempty" tf:"copy_from_host_name,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []PublicDomainNameServiceIDContributorTransformationsInitParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []PublicDomainNameServiceIDContributorValueOverrideInitParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type PublicDomainNameServiceIDContributorObservation struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Boolean) Use the detected host name instead of the request's domain name.
	// Use the detected host name instead of the request's domain name.
	CopyFromHostName *bool `json:"copyFromHostName,omitempty" tf:"copy_from_host_name,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []PublicDomainNameServiceIDContributorTransformationsObservation `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []PublicDomainNameServiceIDContributorValueOverrideObservation `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type PublicDomainNameServiceIDContributorParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	// +kubebuilder:validation:Optional
	ContributionType *string `json:"contributionType" tf:"contribution_type,omitempty"`

	// (Boolean) Use the detected host name instead of the request's domain name.
	// Use the detected host name instead of the request's domain name.
	// +kubebuilder:validation:Optional
	CopyFromHostName *bool `json:"copyFromHostName,omitempty" tf:"copy_from_host_name,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	// +kubebuilder:validation:Optional
	Transformations []PublicDomainNameServiceIDContributorTransformationsParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	// +kubebuilder:validation:Optional
	ValueOverride []PublicDomainNameServiceIDContributorValueOverrideParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type PublicDomainNameServiceIDContributorTransformationsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ServiceIDContributorTransformationsTransformationInitParameters `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type PublicDomainNameServiceIDContributorTransformationsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ServiceIDContributorTransformationsTransformationObservation `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type PublicDomainNameServiceIDContributorTransformationsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Transformation []ServiceIDContributorTransformationsTransformationParameters `json:"transformation" tf:"transformation,omitempty"`
}

type PublicDomainNameServiceIDContributorValueOverrideInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PublicDomainNameServiceIDContributorValueOverrideObservation struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PublicDomainNameServiceIDContributorValueOverrideParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type ServiceExternalWebRequestInitParameters struct {

	// (Block List, Max: 1) A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must all match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them. (see below for nested schema)
	// A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must **all** match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them.
	Conditions []ConditionsInitParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Description
	// Description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (Block List, Min: 1, Max: 1) Contributors to the Service Identifier calculation. All of the Contributors except for the port are always applied. You can exclude the port contribution by disabling the switch. (see below for nested schema)
	// Contributors to the Service Identifier calculation. All of the Contributors except for the port are always applied. You can exclude the port contribution by disabling the switch.
	IDContributors []IDContributorsInitParameters `json:"idContributors,omitempty" tf:"id_contributors,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Set of String) Define a management zone of the process group for which this service detection rule should be created.  Note: in case of external requests/services the PG might not always be known. See here
	// Define a management zone of the process group for which this service detection rule should be created.  Note: in case of external requests/services the PG might not always be known. See [here](https://dt-url.net/9i03b79)
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`

	// (String) Rule name
	// Rule name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ServiceExternalWebRequestObservation struct {

	// (Block List, Max: 1) A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must all match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them. (see below for nested schema)
	// A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must **all** match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them.
	Conditions []ConditionsObservation `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Description
	// Description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List, Min: 1, Max: 1) Contributors to the Service Identifier calculation. All of the Contributors except for the port are always applied. You can exclude the port contribution by disabling the switch. (see below for nested schema)
	// Contributors to the Service Identifier calculation. All of the Contributors except for the port are always applied. You can exclude the port contribution by disabling the switch.
	IDContributors []IDContributorsObservation `json:"idContributors,omitempty" tf:"id_contributors,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Set of String) Define a management zone of the process group for which this service detection rule should be created.  Note: in case of external requests/services the PG might not always be known. See here
	// Define a management zone of the process group for which this service detection rule should be created.  Note: in case of external requests/services the PG might not always be known. See [here](https://dt-url.net/9i03b79)
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`

	// (String) Rule name
	// Rule name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ServiceExternalWebRequestParameters struct {

	// (Block List, Max: 1) A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must all match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them. (see below for nested schema)
	// A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must **all** match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them.
	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Description
	// Description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (Block List, Min: 1, Max: 1) Contributors to the Service Identifier calculation. All of the Contributors except for the port are always applied. You can exclude the port contribution by disabling the switch. (see below for nested schema)
	// Contributors to the Service Identifier calculation. All of the Contributors except for the port are always applied. You can exclude the port contribution by disabling the switch.
	// +kubebuilder:validation:Optional
	IDContributors []IDContributorsParameters `json:"idContributors,omitempty" tf:"id_contributors,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Set of String) Define a management zone of the process group for which this service detection rule should be created.  Note: in case of external requests/services the PG might not always be known. See here
	// Define a management zone of the process group for which this service detection rule should be created.  Note: in case of external requests/services the PG might not always be known. See [here](https://dt-url.net/9i03b79)
	// +kubebuilder:validation:Optional
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`

	// (String) Rule name
	// Rule name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ServiceIDContributorInitParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []TransformationsInitParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ValueOverrideInitParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ServiceIDContributorObservation struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []TransformationsObservation `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ValueOverrideObservation `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ServiceIDContributorParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	// +kubebuilder:validation:Optional
	ContributionType *string `json:"contributionType" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	// +kubebuilder:validation:Optional
	Transformations []TransformationsParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	// +kubebuilder:validation:Optional
	ValueOverride []ValueOverrideParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ServiceIDContributorTransformationsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []TransformationsTransformationInitParameters `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ServiceIDContributorTransformationsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []TransformationsTransformationObservation `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ServiceIDContributorTransformationsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Transformation []TransformationsTransformationParameters `json:"transformation" tf:"transformation,omitempty"`
}

type ServiceIDContributorTransformationsTransformationInitParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ServiceIDContributorTransformationsTransformationObservation struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ServiceIDContributorTransformationsTransformationParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	// +kubebuilder:validation:Optional
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	// +kubebuilder:validation:Optional
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	// +kubebuilder:validation:Optional
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	// +kubebuilder:validation:Optional
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	// +kubebuilder:validation:Optional
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	// +kubebuilder:validation:Optional
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	// +kubebuilder:validation:Optional
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	// +kubebuilder:validation:Optional
	TransformationType *string `json:"transformationType" tf:"transformation_type,omitempty"`
}

type ServiceIDContributorValueOverrideInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ServiceIDContributorValueOverrideObservation struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ServiceIDContributorValueOverrideParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type TransformationInitParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type TransformationObservation struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type TransformationParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	// +kubebuilder:validation:Optional
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	// +kubebuilder:validation:Optional
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	// +kubebuilder:validation:Optional
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	// +kubebuilder:validation:Optional
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	// +kubebuilder:validation:Optional
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	// +kubebuilder:validation:Optional
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	// +kubebuilder:validation:Optional
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	// +kubebuilder:validation:Optional
	TransformationType *string `json:"transformationType" tf:"transformation_type,omitempty"`
}

type TransformationsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []TransformationInitParameters `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type TransformationsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []TransformationObservation `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type TransformationsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Transformation []TransformationParameters `json:"transformation" tf:"transformation,omitempty"`
}

type TransformationsTransformationInitParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type TransformationsTransformationObservation struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type TransformationsTransformationParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	// +kubebuilder:validation:Optional
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	// +kubebuilder:validation:Optional
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	// +kubebuilder:validation:Optional
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
	// +kubebuilder:validation:Optional
	TransformationType *string `json:"transformationType" tf:"transformation_type,omitempty"`
}

type ValueOverrideInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ValueOverrideObservation struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ValueOverrideParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

// ServiceExternalWebRequestSpec defines the desired state of ServiceExternalWebRequest
type ServiceExternalWebRequestSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServiceExternalWebRequestParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ServiceExternalWebRequestInitParameters `json:"initProvider,omitempty"`
}

// ServiceExternalWebRequestStatus defines the observed state of ServiceExternalWebRequest.
type ServiceExternalWebRequestStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceExternalWebRequestObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ServiceExternalWebRequest is the Schema for the ServiceExternalWebRequests API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type ServiceExternalWebRequest struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.idContributors) || (has(self.initProvider) && has(self.initProvider.idContributors))",message="spec.forProvider.idContributors is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ServiceExternalWebRequestSpec   `json:"spec"`
	Status ServiceExternalWebRequestStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceExternalWebRequestList contains a list of ServiceExternalWebRequests
type ServiceExternalWebRequestList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServiceExternalWebRequest `json:"items"`
}

// Repository type metadata.
var (
	ServiceExternalWebRequest_Kind             = "ServiceExternalWebRequest"
	ServiceExternalWebRequest_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ServiceExternalWebRequest_Kind}.String()
	ServiceExternalWebRequest_KindAPIVersion   = ServiceExternalWebRequest_Kind + "." + CRDGroupVersion.String()
	ServiceExternalWebRequest_GroupVersionKind = CRDGroupVersion.WithKind(ServiceExternalWebRequest_Kind)
)

func init() {
	SchemeBuilder.Register(&ServiceExternalWebRequest{}, &ServiceExternalWebRequestList{})
}

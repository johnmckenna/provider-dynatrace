// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationIDServiceIDContributorInitParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ApplicationIDServiceIDContributorTransformationsInitParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ApplicationIDServiceIDContributorValueOverrideInitParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ApplicationIDServiceIDContributorObservation struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ApplicationIDServiceIDContributorTransformationsObservation `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ApplicationIDServiceIDContributorValueOverrideObservation `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ApplicationIDServiceIDContributorParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	// +kubebuilder:validation:Optional
	ContributionType *string `json:"contributionType" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	// +kubebuilder:validation:Optional
	Transformations []ApplicationIDServiceIDContributorTransformationsParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	// +kubebuilder:validation:Optional
	ValueOverride []ApplicationIDServiceIDContributorValueOverrideParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ApplicationIDServiceIDContributorTransformationsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ApplicationIDServiceIDContributorTransformationsTransformationInitParameters `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ApplicationIDServiceIDContributorTransformationsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ApplicationIDServiceIDContributorTransformationsTransformationObservation `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ApplicationIDServiceIDContributorTransformationsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Transformation []ApplicationIDServiceIDContributorTransformationsTransformationParameters `json:"transformation" tf:"transformation,omitempty"`
}

type ApplicationIDServiceIDContributorTransformationsTransformationInitParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ApplicationIDServiceIDContributorTransformationsTransformationObservation struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ApplicationIDServiceIDContributorTransformationsTransformationParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	// +kubebuilder:validation:Optional
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	// +kubebuilder:validation:Optional
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	// +kubebuilder:validation:Optional
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	// +kubebuilder:validation:Optional
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	// +kubebuilder:validation:Optional
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	// +kubebuilder:validation:Optional
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	// +kubebuilder:validation:Optional
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	// +kubebuilder:validation:Optional
	TransformationType *string `json:"transformationType" tf:"transformation_type,omitempty"`
}

type ApplicationIDServiceIDContributorValueOverrideInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ApplicationIDServiceIDContributorValueOverrideObservation struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ApplicationIDServiceIDContributorValueOverrideParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type ContextRootServiceIDContributorTransformationsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ContextRootServiceIDContributorTransformationsTransformationInitParameters `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ContextRootServiceIDContributorTransformationsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ContextRootServiceIDContributorTransformationsTransformationObservation `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ContextRootServiceIDContributorTransformationsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Transformation []ContextRootServiceIDContributorTransformationsTransformationParameters `json:"transformation" tf:"transformation,omitempty"`
}

type ContextRootServiceIDContributorTransformationsTransformationInitParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ContextRootServiceIDContributorTransformationsTransformationObservation struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ContextRootServiceIDContributorTransformationsTransformationParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	// +kubebuilder:validation:Optional
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	// +kubebuilder:validation:Optional
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	// +kubebuilder:validation:Optional
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
	// +kubebuilder:validation:Optional
	TransformationType *string `json:"transformationType" tf:"transformation_type,omitempty"`
}

type ContextRootServiceIDContributorValueOverrideInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ContextRootServiceIDContributorValueOverrideObservation struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ContextRootServiceIDContributorValueOverrideParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type IDContributorsApplicationIDInitParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ApplicationIDServiceIDContributorInitParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type IDContributorsApplicationIDObservation struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ApplicationIDServiceIDContributorObservation `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type IDContributorsApplicationIDParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	// +kubebuilder:validation:Optional
	EnableIDContributor *bool `json:"enableIdContributor" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	// +kubebuilder:validation:Optional
	ServiceIDContributor []ApplicationIDServiceIDContributorParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type IDContributorsContextRootInitParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []IDContributorsContextRootServiceIDContributorInitParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type IDContributorsContextRootObservation struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []IDContributorsContextRootServiceIDContributorObservation `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type IDContributorsContextRootParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	// +kubebuilder:validation:Optional
	EnableIDContributor *bool `json:"enableIdContributor" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	// +kubebuilder:validation:Optional
	ServiceIDContributor []IDContributorsContextRootServiceIDContributorParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type IDContributorsContextRootServiceIDContributorInitParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Number) How many segments should be taken.
	// The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ContextRootServiceIDContributorTransformationsInitParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ContextRootServiceIDContributorValueOverrideInitParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type IDContributorsContextRootServiceIDContributorObservation struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Number) How many segments should be taken.
	// The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ContextRootServiceIDContributorTransformationsObservation `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ContextRootServiceIDContributorValueOverrideObservation `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type IDContributorsContextRootServiceIDContributorParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
	// +kubebuilder:validation:Optional
	ContributionType *string `json:"contributionType" tf:"contribution_type,omitempty"`

	// (Number) How many segments should be taken.
	// The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
	// +kubebuilder:validation:Optional
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	// +kubebuilder:validation:Optional
	Transformations []ContextRootServiceIDContributorTransformationsParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	// +kubebuilder:validation:Optional
	ValueOverride []ContextRootServiceIDContributorValueOverrideParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ServerNameInitParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ServerNameServiceIDContributorInitParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ServerNameObservation struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	EnableIDContributor *bool `json:"enableIdContributor,omitempty" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	ServiceIDContributor []ServerNameServiceIDContributorObservation `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ServerNameParameters struct {

	// (Boolean) Transform this value before letting it contribute to the Service Id
	// Transform this value before letting it contribute to the Service Id
	// +kubebuilder:validation:Optional
	EnableIDContributor *bool `json:"enableIdContributor" tf:"enable_id_contributor,omitempty"`

	// (Block List, Max: 1) no documentation available (see below for nested schema)
	// no documentation available
	// +kubebuilder:validation:Optional
	ServiceIDContributor []ServerNameServiceIDContributorParameters `json:"serviceIdContributor,omitempty" tf:"service_id_contributor,omitempty"`
}

type ServerNameServiceIDContributorInitParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ServerNameServiceIDContributorTransformationsInitParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ServerNameServiceIDContributorValueOverrideInitParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ServerNameServiceIDContributorObservation struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	ContributionType *string `json:"contributionType,omitempty" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	Transformations []ServerNameServiceIDContributorTransformationsObservation `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	ValueOverride []ServerNameServiceIDContributorValueOverrideObservation `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ServerNameServiceIDContributorParameters struct {

	// (String) Possible Values: OriginalValue, OverrideValue, TransformValue
	// Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
	// +kubebuilder:validation:Optional
	ContributionType *string `json:"contributionType" tf:"contribution_type,omitempty"`

	// (Block List, Max: 1) Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
	// +kubebuilder:validation:Optional
	Transformations []ServerNameServiceIDContributorTransformationsParameters `json:"transformations,omitempty" tf:"transformations,omitempty"`

	// (Block List, Max: 1) The value to be used instead of the detected value. (see below for nested schema)
	// The value to be used instead of the detected value.
	// +kubebuilder:validation:Optional
	ValueOverride []ServerNameServiceIDContributorValueOverrideParameters `json:"valueOverride,omitempty" tf:"value_override,omitempty"`
}

type ServerNameServiceIDContributorTransformationsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ServerNameServiceIDContributorTransformationsTransformationInitParameters `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ServerNameServiceIDContributorTransformationsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Transformation []ServerNameServiceIDContributorTransformationsTransformationObservation `json:"transformation,omitempty" tf:"transformation,omitempty"`
}

type ServerNameServiceIDContributorTransformationsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Transformation []ServerNameServiceIDContributorTransformationsTransformationParameters `json:"transformation" tf:"transformation,omitempty"`
}

type ServerNameServiceIDContributorTransformationsTransformationInitParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ServerNameServiceIDContributorTransformationsTransformationObservation struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	TransformationType *string `json:"transformationType,omitempty" tf:"transformation_type,omitempty"`
}

type ServerNameServiceIDContributorTransformationsTransformationParameters struct {

	// (Boolean) include hexadecimal numbers
	// include hexadecimal numbers
	// +kubebuilder:validation:Optional
	IncludeHexNumbers *bool `json:"includeHexNumbers,omitempty" tf:"include_hex_numbers,omitempty"`

	// (Number) min digit count
	// min digit count
	// +kubebuilder:validation:Optional
	MinDigitCount *float64 `json:"minDigitCount,omitempty" tf:"min_digit_count,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// (String) replacement
	// replacement
	// +kubebuilder:validation:Optional
	ReplacementValue *string `json:"replacementValue,omitempty" tf:"replacement_value,omitempty"`

	// (Number) How many segments should be taken.
	// How many segments should be taken.
	// +kubebuilder:validation:Optional
	SegmentCount *float64 `json:"segmentCount,omitempty" tf:"segment_count,omitempty"`

	// (Number) select index
	// select index
	// +kubebuilder:validation:Optional
	SelectIndex *float64 `json:"selectIndex,omitempty" tf:"select_index,omitempty"`

	// (String) split by
	// split by
	// +kubebuilder:validation:Optional
	SplitDelimiter *string `json:"splitDelimiter,omitempty" tf:"split_delimiter,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`

	// (Boolean) take from end
	// take from end
	// +kubebuilder:validation:Optional
	TakeFromEnd *bool `json:"takeFromEnd,omitempty" tf:"take_from_end,omitempty"`

	// (String) Possible Values: AFTER, BEFORE, BETWEEN, REMOVE_CREDIT_CARDS, REMOVE_IBANS, REMOVE_IPS, REMOVE_NUMBERS, REPLACE_BETWEEN, SPLIT_SELECT, TAKE_SEGMENTS
	// Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
	// +kubebuilder:validation:Optional
	TransformationType *string `json:"transformationType" tf:"transformation_type,omitempty"`
}

type ServerNameServiceIDContributorValueOverrideInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ServerNameServiceIDContributorValueOverrideObservation struct {

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ServerNameServiceIDContributorValueOverrideParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type ServiceFullWebRequestConditionsConditionInitParameters struct {

	// (String) Take the value of this attribute
	// Take the value of this attribute
	Attribute *string `json:"attribute,omitempty" tf:"attribute,omitempty"`

	// (String) Apply this operation
	// Apply this operation
	CompareOperationType *string `json:"compareOperationType,omitempty" tf:"compare_operation_type,omitempty"`

	// (Set of String) Technology
	// Technology
	// +listType=set
	Framework []*string `json:"framework,omitempty" tf:"framework,omitempty"`

	// (String) From
	// From
	IPRangeFrom *string `json:"ipRangeFrom,omitempty" tf:"ip_range_from,omitempty"`

	// (String) To
	// To
	IPRangeTo *string `json:"ipRangeTo,omitempty" tf:"ip_range_to,omitempty"`

	// (Boolean) Ignore case sensitivity for texts.
	// Ignore case sensitivity for texts.
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// (Number) Value
	// Value
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (Set of Number) Values
	// Values
	// +listType=set
	IntValues []*float64 `json:"intValues,omitempty" tf:"int_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TagValues []*string `json:"tagValues,omitempty" tf:"tag_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TextValues []*string `json:"textValues,omitempty" tf:"text_values,omitempty"`
}

type ServiceFullWebRequestConditionsConditionObservation struct {

	// (String) Take the value of this attribute
	// Take the value of this attribute
	Attribute *string `json:"attribute,omitempty" tf:"attribute,omitempty"`

	// (String) Apply this operation
	// Apply this operation
	CompareOperationType *string `json:"compareOperationType,omitempty" tf:"compare_operation_type,omitempty"`

	// (Set of String) Technology
	// Technology
	// +listType=set
	Framework []*string `json:"framework,omitempty" tf:"framework,omitempty"`

	// (String) From
	// From
	IPRangeFrom *string `json:"ipRangeFrom,omitempty" tf:"ip_range_from,omitempty"`

	// (String) To
	// To
	IPRangeTo *string `json:"ipRangeTo,omitempty" tf:"ip_range_to,omitempty"`

	// (Boolean) Ignore case sensitivity for texts.
	// Ignore case sensitivity for texts.
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// (Number) Value
	// Value
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (Set of Number) Values
	// Values
	// +listType=set
	IntValues []*float64 `json:"intValues,omitempty" tf:"int_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TagValues []*string `json:"tagValues,omitempty" tf:"tag_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +listType=set
	TextValues []*string `json:"textValues,omitempty" tf:"text_values,omitempty"`
}

type ServiceFullWebRequestConditionsConditionParameters struct {

	// (String) Take the value of this attribute
	// Take the value of this attribute
	// +kubebuilder:validation:Optional
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// (String) Apply this operation
	// Apply this operation
	// +kubebuilder:validation:Optional
	CompareOperationType *string `json:"compareOperationType" tf:"compare_operation_type,omitempty"`

	// (Set of String) Technology
	// Technology
	// +kubebuilder:validation:Optional
	// +listType=set
	Framework []*string `json:"framework,omitempty" tf:"framework,omitempty"`

	// (String) From
	// From
	// +kubebuilder:validation:Optional
	IPRangeFrom *string `json:"ipRangeFrom,omitempty" tf:"ip_range_from,omitempty"`

	// (String) To
	// To
	// +kubebuilder:validation:Optional
	IPRangeTo *string `json:"ipRangeTo,omitempty" tf:"ip_range_to,omitempty"`

	// (Boolean) Ignore case sensitivity for texts.
	// Ignore case sensitivity for texts.
	// +kubebuilder:validation:Optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// (Number) Value
	// Value
	// +kubebuilder:validation:Optional
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (Set of Number) Values
	// Values
	// +kubebuilder:validation:Optional
	// +listType=set
	IntValues []*float64 `json:"intValues,omitempty" tf:"int_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +kubebuilder:validation:Optional
	// +listType=set
	TagValues []*string `json:"tagValues,omitempty" tf:"tag_values,omitempty"`

	// (Set of String) If multiple values are specified, at least one of them must match for the condition to match
	// If multiple values are specified, at least one of them must match for the condition to match
	// +kubebuilder:validation:Optional
	// +listType=set
	TextValues []*string `json:"textValues,omitempty" tf:"text_values,omitempty"`
}

type ServiceFullWebRequestConditionsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Condition []ServiceFullWebRequestConditionsConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`
}

type ServiceFullWebRequestConditionsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Condition []ServiceFullWebRequestConditionsConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`
}

type ServiceFullWebRequestConditionsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Condition []ServiceFullWebRequestConditionsConditionParameters `json:"condition" tf:"condition,omitempty"`
}

type ServiceFullWebRequestIDContributorsInitParameters struct {

	// (Block List, Min: 1, Max: 1) Application identifier (see below for nested schema)
	// Application identifier
	ApplicationID []IDContributorsApplicationIDInitParameters `json:"applicationId,omitempty" tf:"application_id,omitempty"`

	// api/ URL the context root is /support. The context root value can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the **Service overview page** under **Properties and tags**.
	ContextRoot []IDContributorsContextRootInitParameters `json:"contextRoot,omitempty" tf:"context_root,omitempty"`

	// (Block List, Min: 1, Max: 1) Server Name (see below for nested schema)
	// Server Name
	ServerName []ServerNameInitParameters `json:"serverName,omitempty" tf:"server_name,omitempty"`
}

type ServiceFullWebRequestIDContributorsObservation struct {

	// (Block List, Min: 1, Max: 1) Application identifier (see below for nested schema)
	// Application identifier
	ApplicationID []IDContributorsApplicationIDObservation `json:"applicationId,omitempty" tf:"application_id,omitempty"`

	// api/ URL the context root is /support. The context root value can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the **Service overview page** under **Properties and tags**.
	ContextRoot []IDContributorsContextRootObservation `json:"contextRoot,omitempty" tf:"context_root,omitempty"`

	// (Block List, Min: 1, Max: 1) Server Name (see below for nested schema)
	// Server Name
	ServerName []ServerNameObservation `json:"serverName,omitempty" tf:"server_name,omitempty"`
}

type ServiceFullWebRequestIDContributorsParameters struct {

	// (Block List, Min: 1, Max: 1) Application identifier (see below for nested schema)
	// Application identifier
	// +kubebuilder:validation:Optional
	ApplicationID []IDContributorsApplicationIDParameters `json:"applicationId" tf:"application_id,omitempty"`

	// api/ URL the context root is /support. The context root value can be found on the Service overview page under Properties and tags. (see below for nested schema)
	// The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the **Service overview page** under **Properties and tags**.
	// +kubebuilder:validation:Optional
	ContextRoot []IDContributorsContextRootParameters `json:"contextRoot" tf:"context_root,omitempty"`

	// (Block List, Min: 1, Max: 1) Server Name (see below for nested schema)
	// Server Name
	// +kubebuilder:validation:Optional
	ServerName []ServerNameParameters `json:"serverName" tf:"server_name,omitempty"`
}

type ServiceFullWebRequestInitParameters struct {

	// (Block List, Max: 1) A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must all match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them. (see below for nested schema)
	// A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must **all** match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them.
	Conditions []ServiceFullWebRequestConditionsInitParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Description
	// Description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (Block List, Min: 1, Max: 1) Contributors to the Service Identifier calculation. All of the Contributors are always applied. (see below for nested schema)
	// Contributors to the Service Identifier calculation. All of the Contributors are always applied.
	IDContributors []ServiceFullWebRequestIDContributorsInitParameters `json:"idContributors,omitempty" tf:"id_contributors,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Set of String) Define a management zone of the process group for which this service detection rule should be created.
	// Define a management zone of the process group for which this service detection rule should be created.
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`

	// (String) Rule name
	// Rule name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ServiceFullWebRequestObservation struct {

	// (Block List, Max: 1) A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must all match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them. (see below for nested schema)
	// A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must **all** match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them.
	Conditions []ServiceFullWebRequestConditionsObservation `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Description
	// Description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List, Min: 1, Max: 1) Contributors to the Service Identifier calculation. All of the Contributors are always applied. (see below for nested schema)
	// Contributors to the Service Identifier calculation. All of the Contributors are always applied.
	IDContributors []ServiceFullWebRequestIDContributorsObservation `json:"idContributors,omitempty" tf:"id_contributors,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Set of String) Define a management zone of the process group for which this service detection rule should be created.
	// Define a management zone of the process group for which this service detection rule should be created.
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`

	// (String) Rule name
	// Rule name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ServiceFullWebRequestParameters struct {

	// (Block List, Max: 1) A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must all match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them. (see below for nested schema)
	// A list of conditions necessary for the rule to take effect. If multiple conditions are specified, they must **all** match a Request for the rule to apply. If there is no condition at all, the rule is always applied. Conditions are evaluated against attributes, but do not modify them.
	// +kubebuilder:validation:Optional
	Conditions []ServiceFullWebRequestConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Description
	// Description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (Block List, Min: 1, Max: 1) Contributors to the Service Identifier calculation. All of the Contributors are always applied. (see below for nested schema)
	// Contributors to the Service Identifier calculation. All of the Contributors are always applied.
	// +kubebuilder:validation:Optional
	IDContributors []ServiceFullWebRequestIDContributorsParameters `json:"idContributors,omitempty" tf:"id_contributors,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Set of String) Define a management zone of the process group for which this service detection rule should be created.
	// Define a management zone of the process group for which this service detection rule should be created.
	// +kubebuilder:validation:Optional
	// +listType=set
	ManagementZones []*string `json:"managementZones,omitempty" tf:"management_zones,omitempty"`

	// (String) Rule name
	// Rule name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

// ServiceFullWebRequestSpec defines the desired state of ServiceFullWebRequest
type ServiceFullWebRequestSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServiceFullWebRequestParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ServiceFullWebRequestInitParameters `json:"initProvider,omitempty"`
}

// ServiceFullWebRequestStatus defines the observed state of ServiceFullWebRequest.
type ServiceFullWebRequestStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceFullWebRequestObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ServiceFullWebRequest is the Schema for the ServiceFullWebRequests API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type ServiceFullWebRequest struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.idContributors) || (has(self.initProvider) && has(self.initProvider.idContributors))",message="spec.forProvider.idContributors is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ServiceFullWebRequestSpec   `json:"spec"`
	Status ServiceFullWebRequestStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceFullWebRequestList contains a list of ServiceFullWebRequests
type ServiceFullWebRequestList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServiceFullWebRequest `json:"items"`
}

// Repository type metadata.
var (
	ServiceFullWebRequest_Kind             = "ServiceFullWebRequest"
	ServiceFullWebRequest_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ServiceFullWebRequest_Kind}.String()
	ServiceFullWebRequest_KindAPIVersion   = ServiceFullWebRequest_Kind + "." + CRDGroupVersion.String()
	ServiceFullWebRequest_GroupVersionKind = CRDGroupVersion.WithKind(ServiceFullWebRequest_Kind)
)

func init() {
	SchemeBuilder.Register(&ServiceFullWebRequest{}, &ServiceFullWebRequestList{})
}

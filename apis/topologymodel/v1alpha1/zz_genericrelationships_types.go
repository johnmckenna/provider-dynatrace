// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type GenericRelationshipsInitParameters struct {

	// (String) The user or extension that created this relationship.
	// The user or extension that created this relationship.
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
	// Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
	FromRole *string `json:"fromRole,omitempty" tf:"from_role,omitempty"`

	// (String) Define an entity type as the source of the relationship.
	// Define an entity type as the source of the relationship.
	FromType *string `json:"fromType,omitempty" tf:"from_type,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match. (see below for nested schema)
	// Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match.
	Sources []SourcesInitParameters `json:"sources,omitempty" tf:"sources,omitempty"`

	// (String) Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
	// Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
	ToRole *string `json:"toRole,omitempty" tf:"to_role,omitempty"`

	// (String) Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
	// Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
	ToType *string `json:"toType,omitempty" tf:"to_type,omitempty"`

	// (String) Possible Values: CALLS, CHILD_OF, INSTANCE_OF, PART_OF, RUNS_ON, SAME_AS
	// Possible Values: `CALLS`, `CHILD_OF`, `INSTANCE_OF`, `PART_OF`, `RUNS_ON`, `SAME_AS`
	TypeOfRelation *string `json:"typeOfRelation,omitempty" tf:"type_of_relation,omitempty"`
}

type GenericRelationshipsObservation struct {

	// (String) The user or extension that created this relationship.
	// The user or extension that created this relationship.
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
	// Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
	FromRole *string `json:"fromRole,omitempty" tf:"from_role,omitempty"`

	// (String) Define an entity type as the source of the relationship.
	// Define an entity type as the source of the relationship.
	FromType *string `json:"fromType,omitempty" tf:"from_type,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match. (see below for nested schema)
	// Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match.
	Sources []SourcesObservation `json:"sources,omitempty" tf:"sources,omitempty"`

	// (String) Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
	// Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
	ToRole *string `json:"toRole,omitempty" tf:"to_role,omitempty"`

	// (String) Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
	// Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
	ToType *string `json:"toType,omitempty" tf:"to_type,omitempty"`

	// (String) Possible Values: CALLS, CHILD_OF, INSTANCE_OF, PART_OF, RUNS_ON, SAME_AS
	// Possible Values: `CALLS`, `CHILD_OF`, `INSTANCE_OF`, `PART_OF`, `RUNS_ON`, `SAME_AS`
	TypeOfRelation *string `json:"typeOfRelation,omitempty" tf:"type_of_relation,omitempty"`
}

type GenericRelationshipsParameters struct {

	// (String) The user or extension that created this relationship.
	// The user or extension that created this relationship.
	// +kubebuilder:validation:Optional
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
	// Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
	// +kubebuilder:validation:Optional
	FromRole *string `json:"fromRole,omitempty" tf:"from_role,omitempty"`

	// (String) Define an entity type as the source of the relationship.
	// Define an entity type as the source of the relationship.
	// +kubebuilder:validation:Optional
	FromType *string `json:"fromType,omitempty" tf:"from_type,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match. (see below for nested schema)
	// Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match.
	// +kubebuilder:validation:Optional
	Sources []SourcesParameters `json:"sources,omitempty" tf:"sources,omitempty"`

	// (String) Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
	// Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
	// +kubebuilder:validation:Optional
	ToRole *string `json:"toRole,omitempty" tf:"to_role,omitempty"`

	// (String) Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
	// Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
	// +kubebuilder:validation:Optional
	ToType *string `json:"toType,omitempty" tf:"to_type,omitempty"`

	// (String) Possible Values: CALLS, CHILD_OF, INSTANCE_OF, PART_OF, RUNS_ON, SAME_AS
	// Possible Values: `CALLS`, `CHILD_OF`, `INSTANCE_OF`, `PART_OF`, `RUNS_ON`, `SAME_AS`
	// +kubebuilder:validation:Optional
	TypeOfRelation *string `json:"typeOfRelation,omitempty" tf:"type_of_relation,omitempty"`
}

type MappingRuleInitParameters struct {

	// sensitive name of a property of the destination type.
	// The case-sensitive name of a property of the destination type.
	DestinationProperty *string `json:"destinationProperty,omitempty" tf:"destination_property,omitempty"`

	// (String) Possible Values: Leavetextas_is, Tolowercase, Touppercase
	// Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
	DestinationTransformation *string `json:"destinationTransformation,omitempty" tf:"destination_transformation,omitempty"`

	// sensitive name of a property of the source type.
	// The case-sensitive name of a property of the source type.
	SourceProperty *string `json:"sourceProperty,omitempty" tf:"source_property,omitempty"`

	// (String) Possible Values: Leavetextas_is, Tolowercase, Touppercase
	// Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
	SourceTransformation *string `json:"sourceTransformation,omitempty" tf:"source_transformation,omitempty"`
}

type MappingRuleObservation struct {

	// sensitive name of a property of the destination type.
	// The case-sensitive name of a property of the destination type.
	DestinationProperty *string `json:"destinationProperty,omitempty" tf:"destination_property,omitempty"`

	// (String) Possible Values: Leavetextas_is, Tolowercase, Touppercase
	// Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
	DestinationTransformation *string `json:"destinationTransformation,omitempty" tf:"destination_transformation,omitempty"`

	// sensitive name of a property of the source type.
	// The case-sensitive name of a property of the source type.
	SourceProperty *string `json:"sourceProperty,omitempty" tf:"source_property,omitempty"`

	// (String) Possible Values: Leavetextas_is, Tolowercase, Touppercase
	// Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
	SourceTransformation *string `json:"sourceTransformation,omitempty" tf:"source_transformation,omitempty"`
}

type MappingRuleParameters struct {

	// sensitive name of a property of the destination type.
	// The case-sensitive name of a property of the destination type.
	// +kubebuilder:validation:Optional
	DestinationProperty *string `json:"destinationProperty" tf:"destination_property,omitempty"`

	// (String) Possible Values: Leavetextas_is, Tolowercase, Touppercase
	// Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
	// +kubebuilder:validation:Optional
	DestinationTransformation *string `json:"destinationTransformation" tf:"destination_transformation,omitempty"`

	// sensitive name of a property of the source type.
	// The case-sensitive name of a property of the source type.
	// +kubebuilder:validation:Optional
	SourceProperty *string `json:"sourceProperty" tf:"source_property,omitempty"`

	// (String) Possible Values: Leavetextas_is, Tolowercase, Touppercase
	// Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
	// +kubebuilder:validation:Optional
	SourceTransformation *string `json:"sourceTransformation" tf:"source_transformation,omitempty"`
}

type MappingRulesInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	MappingRule []MappingRuleInitParameters `json:"mappingRule,omitempty" tf:"mapping_rule,omitempty"`
}

type MappingRulesObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	MappingRule []MappingRuleObservation `json:"mappingRule,omitempty" tf:"mapping_rule,omitempty"`
}

type MappingRulesParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	MappingRule []MappingRuleParameters `json:"mappingRule" tf:"mapping_rule,omitempty"`
}

type SourceInitParameters struct {

	// (String) Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: $eq(value) will ensure that the source matches exactly 'value', while $prefix(value) will ensure that the source begins with exactly 'value'.
	// If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
	// Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', while `$prefix(value)` will ensure that the source begins with exactly 'value'.
	// If your value contains the characters '(', ')' or '\~', you need to escape them by adding a '\~' in front of them.
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Block List, Max: 1) Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created. (see below for nested schema)
	// Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created.
	MappingRules []MappingRulesInitParameters `json:"mappingRules,omitempty" tf:"mapping_rules,omitempty"`

	// (String) Possible Values: BusinessEvents, Entities, Events, Logs, Metrics, Spans, Topology
	// Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type SourceObservation struct {

	// (String) Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: $eq(value) will ensure that the source matches exactly 'value', while $prefix(value) will ensure that the source begins with exactly 'value'.
	// If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
	// Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', while `$prefix(value)` will ensure that the source begins with exactly 'value'.
	// If your value contains the characters '(', ')' or '\~', you need to escape them by adding a '\~' in front of them.
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Block List, Max: 1) Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created. (see below for nested schema)
	// Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created.
	MappingRules []MappingRulesObservation `json:"mappingRules,omitempty" tf:"mapping_rules,omitempty"`

	// (String) Possible Values: BusinessEvents, Entities, Events, Logs, Metrics, Spans, Topology
	// Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type SourceParameters struct {

	// (String) Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: $eq(value) will ensure that the source matches exactly 'value', while $prefix(value) will ensure that the source begins with exactly 'value'.
	// If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
	// Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', while `$prefix(value)` will ensure that the source begins with exactly 'value'.
	// If your value contains the characters '(', ')' or '\~', you need to escape them by adding a '\~' in front of them.
	// +kubebuilder:validation:Optional
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Block List, Max: 1) Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created. (see below for nested schema)
	// Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created.
	// +kubebuilder:validation:Optional
	MappingRules []MappingRulesParameters `json:"mappingRules,omitempty" tf:"mapping_rules,omitempty"`

	// (String) Possible Values: BusinessEvents, Entities, Events, Logs, Metrics, Spans, Topology
	// Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
	// +kubebuilder:validation:Optional
	SourceType *string `json:"sourceType" tf:"source_type,omitempty"`
}

type SourcesInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Source []SourceInitParameters `json:"source,omitempty" tf:"source,omitempty"`
}

type SourcesObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Source []SourceObservation `json:"source,omitempty" tf:"source,omitempty"`
}

type SourcesParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Source []SourceParameters `json:"source" tf:"source,omitempty"`
}

// GenericRelationshipsSpec defines the desired state of GenericRelationships
type GenericRelationshipsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     GenericRelationshipsParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider GenericRelationshipsInitParameters `json:"initProvider,omitempty"`
}

// GenericRelationshipsStatus defines the observed state of GenericRelationships.
type GenericRelationshipsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        GenericRelationshipsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// GenericRelationships is the Schema for the GenericRelationshipss API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type GenericRelationships struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.createdBy) || (has(self.initProvider) && has(self.initProvider.createdBy))",message="spec.forProvider.createdBy is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.fromType) || (has(self.initProvider) && has(self.initProvider.fromType))",message="spec.forProvider.fromType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.sources) || (has(self.initProvider) && has(self.initProvider.sources))",message="spec.forProvider.sources is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.toType) || (has(self.initProvider) && has(self.initProvider.toType))",message="spec.forProvider.toType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.typeOfRelation) || (has(self.initProvider) && has(self.initProvider.typeOfRelation))",message="spec.forProvider.typeOfRelation is a required parameter"
	Spec   GenericRelationshipsSpec   `json:"spec"`
	Status GenericRelationshipsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GenericRelationshipsList contains a list of GenericRelationshipss
type GenericRelationshipsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GenericRelationships `json:"items"`
}

// Repository type metadata.
var (
	GenericRelationships_Kind             = "GenericRelationships"
	GenericRelationships_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: GenericRelationships_Kind}.String()
	GenericRelationships_KindAPIVersion   = GenericRelationships_Kind + "." + CRDGroupVersion.String()
	GenericRelationships_GroupVersionKind = CRDGroupVersion.WithKind(GenericRelationships_Kind)
)

func init() {
	SchemeBuilder.Register(&GenericRelationships{}, &GenericRelationshipsList{})
}

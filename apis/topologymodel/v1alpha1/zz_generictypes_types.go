// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AttributeInitParameters struct {

	// (String) The human readable type name for this entity type.
	// The human readable attribute name for this extraction rule. Leave blank to use the key as the display name.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (String) The attribute key is the unique name of the attribute.
	// The attribute key is the unique name of the attribute.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
	// Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type AttributeObservation struct {

	// (String) The human readable type name for this entity type.
	// The human readable attribute name for this extraction rule. Leave blank to use the key as the display name.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (String) The attribute key is the unique name of the attribute.
	// The attribute key is the unique name of the attribute.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
	// Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type AttributeParameters struct {

	// (String) The human readable type name for this entity type.
	// The human readable attribute name for this extraction rule. Leave blank to use the key as the display name.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (String) The attribute key is the unique name of the attribute.
	// The attribute key is the unique name of the attribute.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
	// Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type AttributesInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Attribute []AttributeInitParameters `json:"attribute,omitempty" tf:"attribute,omitempty"`
}

type AttributesObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Attribute []AttributeObservation `json:"attribute,omitempty" tf:"attribute,omitempty"`
}

type AttributesParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Attribute []AttributeParameters `json:"attribute" tf:"attribute,omitempty"`
}

type GenericTypesInitParameters struct {

	// (String) The user or extension that created this type.
	// The user or extension that created this type.
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// (String) The human readable type name for this entity type.
	// The human readable type name for this entity type.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (String) The entity type name. This type name must be unique and must not be changed after creation.
	// The entity type name. This type name must be unique and must not be changed after creation.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify a list of rules which are evaluated in order. When any rule matches, the entity defined according to that rule will be extracted. Subsequent rules will not be evaluated. (see below for nested schema)
	// Specify a list of rules which are evaluated in order. When **any** rule matches, the entity defined according to that rule will be extracted. Subsequent rules will not be evaluated.
	Rules []RulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type GenericTypesObservation struct {

	// (String) The user or extension that created this type.
	// The user or extension that created this type.
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// (String) The human readable type name for this entity type.
	// The human readable type name for this entity type.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (String) The entity type name. This type name must be unique and must not be changed after creation.
	// The entity type name. This type name must be unique and must not be changed after creation.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify a list of rules which are evaluated in order. When any rule matches, the entity defined according to that rule will be extracted. Subsequent rules will not be evaluated. (see below for nested schema)
	// Specify a list of rules which are evaluated in order. When **any** rule matches, the entity defined according to that rule will be extracted. Subsequent rules will not be evaluated.
	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`
}

type GenericTypesParameters struct {

	// (String) The user or extension that created this type.
	// The user or extension that created this type.
	// +kubebuilder:validation:Optional
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// (String) The human readable type name for this entity type.
	// The human readable type name for this entity type.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (String) The entity type name. This type name must be unique and must not be changed after creation.
	// The entity type name. This type name must be unique and must not be changed after creation.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify a list of rules which are evaluated in order. When any rule matches, the entity defined according to that rule will be extracted. Subsequent rules will not be evaluated. (see below for nested schema)
	// Specify a list of rules which are evaluated in order. When **any** rule matches, the entity defined according to that rule will be extracted. Subsequent rules will not be evaluated.
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type RequiredDimensionInitParameters struct {

	// (String) The attribute key is the unique name of the attribute.
	// A dimension key which needs to exist in the ingest data to match this filter.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) A dimension value pattern which needs to exist in the ingest data to match this filter.
	// A dimension value pattern which needs to exist in the ingest data to match this filter.
	ValuePattern *string `json:"valuePattern,omitempty" tf:"value_pattern,omitempty"`
}

type RequiredDimensionObservation struct {

	// (String) The attribute key is the unique name of the attribute.
	// A dimension key which needs to exist in the ingest data to match this filter.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) A dimension value pattern which needs to exist in the ingest data to match this filter.
	// A dimension value pattern which needs to exist in the ingest data to match this filter.
	ValuePattern *string `json:"valuePattern,omitempty" tf:"value_pattern,omitempty"`
}

type RequiredDimensionParameters struct {

	// (String) The attribute key is the unique name of the attribute.
	// A dimension key which needs to exist in the ingest data to match this filter.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) A dimension value pattern which needs to exist in the ingest data to match this filter.
	// A dimension value pattern which needs to exist in the ingest data to match this filter.
	// +kubebuilder:validation:Optional
	ValuePattern *string `json:"valuePattern,omitempty" tf:"value_pattern,omitempty"`
}

type RequiredDimensionsInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	RequiredDimension []RequiredDimensionInitParameters `json:"requiredDimension,omitempty" tf:"required_dimension,omitempty"`
}

type RequiredDimensionsObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	RequiredDimension []RequiredDimensionObservation `json:"requiredDimension,omitempty" tf:"required_dimension,omitempty"`
}

type RequiredDimensionsParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	RequiredDimension []RequiredDimensionParameters `json:"requiredDimension" tf:"required_dimension,omitempty"`
}

type RuleInitParameters struct {

	// (Block List, Max: 1) All attribute extraction rules will be applied and found attributes will be added to the extracted type. (see below for nested schema)
	// All attribute extraction rules will be applied and found attributes will be added to the extracted type.
	Attributes []AttributesInitParameters `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
	// ID patterns are comprised of static text and placeholders referring to dimensions in the ingest data. An ID pattern **must** contain at least one placeholder to ensure that different entities will be created.. Take care that the pattern results in the same ID for the same entity. For example, using timestamp or counter-like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
	//
	// Each dimension key referred to by an identifier placeholder must be present in order to extract an entity. If any dimension key referred to in the identifier is missing, the rule will not be considered for evaluation. If you have cases where you still want to extract the same entity type but have differently named keys, consider creating multiple rules extracting the same entity type. In this case take care that each ID pattern evaluates to the same value if the same entity should be extracted.
	IDPattern *string `json:"idPattern,omitempty" tf:"id_pattern,omitempty"`

	// (String) Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
	// Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
	IconPattern *string `json:"iconPattern,omitempty" tf:"icon_pattern,omitempty"`

	// (String) Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
	// Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
	InstanceNamePattern *string `json:"instanceNamePattern,omitempty" tf:"instance_name_pattern,omitempty"`

	// (Block List, Max: 1) In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule. (see below for nested schema)
	// In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule.
	RequiredDimensions []RequiredDimensionsInitParameters `json:"requiredDimensions,omitempty" tf:"required_dimensions,omitempty"`

	// (String) If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
	// If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
	Role *string `json:"role,omitempty" tf:"role,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match. (see below for nested schema)
	// Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match.
	Sources []RuleSourcesInitParameters `json:"sources,omitempty" tf:"sources,omitempty"`
}

type RuleObservation struct {

	// (Block List, Max: 1) All attribute extraction rules will be applied and found attributes will be added to the extracted type. (see below for nested schema)
	// All attribute extraction rules will be applied and found attributes will be added to the extracted type.
	Attributes []AttributesObservation `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
	// ID patterns are comprised of static text and placeholders referring to dimensions in the ingest data. An ID pattern **must** contain at least one placeholder to ensure that different entities will be created.. Take care that the pattern results in the same ID for the same entity. For example, using timestamp or counter-like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
	//
	// Each dimension key referred to by an identifier placeholder must be present in order to extract an entity. If any dimension key referred to in the identifier is missing, the rule will not be considered for evaluation. If you have cases where you still want to extract the same entity type but have differently named keys, consider creating multiple rules extracting the same entity type. In this case take care that each ID pattern evaluates to the same value if the same entity should be extracted.
	IDPattern *string `json:"idPattern,omitempty" tf:"id_pattern,omitempty"`

	// (String) Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
	// Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
	IconPattern *string `json:"iconPattern,omitempty" tf:"icon_pattern,omitempty"`

	// (String) Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
	// Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
	InstanceNamePattern *string `json:"instanceNamePattern,omitempty" tf:"instance_name_pattern,omitempty"`

	// (Block List, Max: 1) In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule. (see below for nested schema)
	// In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule.
	RequiredDimensions []RequiredDimensionsObservation `json:"requiredDimensions,omitempty" tf:"required_dimensions,omitempty"`

	// (String) If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
	// If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
	Role *string `json:"role,omitempty" tf:"role,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match. (see below for nested schema)
	// Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match.
	Sources []RuleSourcesObservation `json:"sources,omitempty" tf:"sources,omitempty"`
}

type RuleParameters struct {

	// (Block List, Max: 1) All attribute extraction rules will be applied and found attributes will be added to the extracted type. (see below for nested schema)
	// All attribute extraction rules will be applied and found attributes will be added to the extracted type.
	// +kubebuilder:validation:Optional
	Attributes []AttributesParameters `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
	// ID patterns are comprised of static text and placeholders referring to dimensions in the ingest data. An ID pattern **must** contain at least one placeholder to ensure that different entities will be created.. Take care that the pattern results in the same ID for the same entity. For example, using timestamp or counter-like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
	//
	// Each dimension key referred to by an identifier placeholder must be present in order to extract an entity. If any dimension key referred to in the identifier is missing, the rule will not be considered for evaluation. If you have cases where you still want to extract the same entity type but have differently named keys, consider creating multiple rules extracting the same entity type. In this case take care that each ID pattern evaluates to the same value if the same entity should be extracted.
	// +kubebuilder:validation:Optional
	IDPattern *string `json:"idPattern" tf:"id_pattern,omitempty"`

	// (String) Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
	// Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
	// +kubebuilder:validation:Optional
	IconPattern *string `json:"iconPattern,omitempty" tf:"icon_pattern,omitempty"`

	// (String) Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
	// Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
	// +kubebuilder:validation:Optional
	InstanceNamePattern *string `json:"instanceNamePattern,omitempty" tf:"instance_name_pattern,omitempty"`

	// (Block List, Max: 1) In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule. (see below for nested schema)
	// In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule.
	// +kubebuilder:validation:Optional
	RequiredDimensions []RequiredDimensionsParameters `json:"requiredDimensions,omitempty" tf:"required_dimensions,omitempty"`

	// (String) If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
	// If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
	// +kubebuilder:validation:Optional
	Role *string `json:"role,omitempty" tf:"role,omitempty"`

	// (Block List, Min: 1, Max: 1) Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match. (see below for nested schema)
	// Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match.
	// +kubebuilder:validation:Optional
	Sources []RuleSourcesParameters `json:"sources" tf:"sources,omitempty"`
}

type RuleSourcesInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Source []SourcesSourceInitParameters `json:"source,omitempty" tf:"source,omitempty"`
}

type RuleSourcesObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Source []SourcesSourceObservation `json:"source,omitempty" tf:"source,omitempty"`
}

type RuleSourcesParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Source []SourcesSourceParameters `json:"source" tf:"source,omitempty"`
}

type RulesInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Rule []RuleInitParameters `json:"rule,omitempty" tf:"rule,omitempty"`
}

type RulesObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Rule []RuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`
}

type RulesParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule" tf:"rule,omitempty"`
}

type SourcesSourceInitParameters struct {

	// (String) Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: $eq(value) will ensure that the source matches exactly 'value', $prefix(value) will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
	// If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
	// Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', `$prefix(value)` will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
	// If your value contains the characters '(', ')' or '\~', you need to escape them by adding a '\~' in front of them.
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (String) Possible Values: BusinessEvents, Entities, Events, Logs, Metrics, Spans, Topology
	// Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type SourcesSourceObservation struct {

	// (String) Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: $eq(value) will ensure that the source matches exactly 'value', $prefix(value) will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
	// If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
	// Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', `$prefix(value)` will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
	// If your value contains the characters '(', ')' or '\~', you need to escape them by adding a '\~' in front of them.
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (String) Possible Values: BusinessEvents, Entities, Events, Logs, Metrics, Spans, Topology
	// Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`
}

type SourcesSourceParameters struct {

	// (String) Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: $eq(value) will ensure that the source matches exactly 'value', $prefix(value) will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
	// If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
	// Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', `$prefix(value)` will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
	// If your value contains the characters '(', ')' or '\~', you need to escape them by adding a '\~' in front of them.
	// +kubebuilder:validation:Optional
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// (String) Possible Values: BusinessEvents, Entities, Events, Logs, Metrics, Spans, Topology
	// Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
	// +kubebuilder:validation:Optional
	SourceType *string `json:"sourceType" tf:"source_type,omitempty"`
}

// GenericTypesSpec defines the desired state of GenericTypes
type GenericTypesSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     GenericTypesParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider GenericTypesInitParameters `json:"initProvider,omitempty"`
}

// GenericTypesStatus defines the observed state of GenericTypes.
type GenericTypesStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        GenericTypesObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// GenericTypes is the Schema for the GenericTypess API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type GenericTypes struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.createdBy) || (has(self.initProvider) && has(self.initProvider.createdBy))",message="spec.forProvider.createdBy is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.displayName) || (has(self.initProvider) && has(self.initProvider.displayName))",message="spec.forProvider.displayName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.rules) || (has(self.initProvider) && has(self.initProvider.rules))",message="spec.forProvider.rules is a required parameter"
	Spec   GenericTypesSpec   `json:"spec"`
	Status GenericTypesStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GenericTypesList contains a list of GenericTypess
type GenericTypesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GenericTypes `json:"items"`
}

// Repository type metadata.
var (
	GenericTypes_Kind             = "GenericTypes"
	GenericTypes_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: GenericTypes_Kind}.String()
	GenericTypes_KindAPIVersion   = GenericTypes_Kind + "." + CRDGroupVersion.String()
	GenericTypes_GroupVersionKind = CRDGroupVersion.WithKind(GenericTypes_Kind)
)

func init() {
	SchemeBuilder.Register(&GenericTypes{}, &GenericTypesList{})
}

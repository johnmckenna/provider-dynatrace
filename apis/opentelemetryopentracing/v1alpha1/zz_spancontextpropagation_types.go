// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MatchesMatchInitParameters struct {

	// (Boolean) Whether to match strings case sensitively or not
	// Whether to match strings case sensitively or not
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Possible values are EQUALS, CONTAINS, STARTS_WITH, ENDS_WITH, DOES_NOT_EQUAL, DOES_NOT_CONTAIN, DOES_NOT_START_WITH and DOES_NOT_END_WITH.
	// Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
	Comparison *string `json:"comparison,omitempty" tf:"comparison,omitempty"`

	// (String) The name of the attribute if source is ATTRIBUTE
	// The name of the attribute if `source` is `ATTRIBUTE`
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) What to match against. Possible values are SPAN_NAME, SPAN_KIND, ATTRIBUTE, INSTRUMENTATION_LIBRARY_NAME and INSTRUMENTATION_LIBRARY_VERSION
	// What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// (String) The value to compare against. When source is SPAN_KIND the only allowed values are INTERNAL, SERVER, CLIENT, PRODUCER and CONSUMER
	// The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MatchesMatchObservation struct {

	// (Boolean) Whether to match strings case sensitively or not
	// Whether to match strings case sensitively or not
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Possible values are EQUALS, CONTAINS, STARTS_WITH, ENDS_WITH, DOES_NOT_EQUAL, DOES_NOT_CONTAIN, DOES_NOT_START_WITH and DOES_NOT_END_WITH.
	// Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
	Comparison *string `json:"comparison,omitempty" tf:"comparison,omitempty"`

	// (String) The name of the attribute if source is ATTRIBUTE
	// The name of the attribute if `source` is `ATTRIBUTE`
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) What to match against. Possible values are SPAN_NAME, SPAN_KIND, ATTRIBUTE, INSTRUMENTATION_LIBRARY_NAME and INSTRUMENTATION_LIBRARY_VERSION
	// What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// (String) The value to compare against. When source is SPAN_KIND the only allowed values are INTERNAL, SERVER, CLIENT, PRODUCER and CONSUMER
	// The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MatchesMatchParameters struct {

	// (Boolean) Whether to match strings case sensitively or not
	// Whether to match strings case sensitively or not
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Possible values are EQUALS, CONTAINS, STARTS_WITH, ENDS_WITH, DOES_NOT_EQUAL, DOES_NOT_CONTAIN, DOES_NOT_START_WITH and DOES_NOT_END_WITH.
	// Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
	// +kubebuilder:validation:Optional
	Comparison *string `json:"comparison" tf:"comparison,omitempty"`

	// (String) The name of the attribute if source is ATTRIBUTE
	// The name of the attribute if `source` is `ATTRIBUTE`
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) What to match against. Possible values are SPAN_NAME, SPAN_KIND, ATTRIBUTE, INSTRUMENTATION_LIBRARY_NAME and INSTRUMENTATION_LIBRARY_VERSION
	// What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
	// +kubebuilder:validation:Optional
	Source *string `json:"source" tf:"source,omitempty"`

	// (String) The value to compare against. When source is SPAN_KIND the only allowed values are INTERNAL, SERVER, CLIENT, PRODUCER and CONSUMER
	// The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SpanContextPropagationInitParameters struct {

	// (String) Whether to create an entry point or not
	// Whether to create an entry point or not
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Matches []SpanContextPropagationMatchesInitParameters `json:"matches,omitempty" tf:"matches,omitempty"`

	// (String) The name of the rule
	// The name of the rule
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SpanContextPropagationMatchesInitParameters struct {

	// (Block List, Min: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Match []MatchesMatchInitParameters `json:"match,omitempty" tf:"match,omitempty"`
}

type SpanContextPropagationMatchesObservation struct {

	// (Block List, Min: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Match []MatchesMatchObservation `json:"match,omitempty" tf:"match,omitempty"`
}

type SpanContextPropagationMatchesParameters struct {

	// (Block List, Min: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	// +kubebuilder:validation:Optional
	Match []MatchesMatchParameters `json:"match" tf:"match,omitempty"`
}

type SpanContextPropagationObservation struct {

	// (String) Whether to create an entry point or not
	// Whether to create an entry point or not
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Matches []SpanContextPropagationMatchesObservation `json:"matches,omitempty" tf:"matches,omitempty"`

	// (String) The name of the rule
	// The name of the rule
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SpanContextPropagationParameters struct {

	// (String) Whether to create an entry point or not
	// Whether to create an entry point or not
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	// +kubebuilder:validation:Optional
	Matches []SpanContextPropagationMatchesParameters `json:"matches,omitempty" tf:"matches,omitempty"`

	// (String) The name of the rule
	// The name of the rule
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

// SpanContextPropagationSpec defines the desired state of SpanContextPropagation
type SpanContextPropagationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SpanContextPropagationParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SpanContextPropagationInitParameters `json:"initProvider,omitempty"`
}

// SpanContextPropagationStatus defines the observed state of SpanContextPropagation.
type SpanContextPropagationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SpanContextPropagationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SpanContextPropagation is the Schema for the SpanContextPropagations API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type SpanContextPropagation struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.action) || (has(self.initProvider) && has(self.initProvider.action))",message="spec.forProvider.action is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.matches) || (has(self.initProvider) && has(self.initProvider.matches))",message="spec.forProvider.matches is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   SpanContextPropagationSpec   `json:"spec"`
	Status SpanContextPropagationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SpanContextPropagationList contains a list of SpanContextPropagations
type SpanContextPropagationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SpanContextPropagation `json:"items"`
}

// Repository type metadata.
var (
	SpanContextPropagation_Kind             = "SpanContextPropagation"
	SpanContextPropagation_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SpanContextPropagation_Kind}.String()
	SpanContextPropagation_KindAPIVersion   = SpanContextPropagation_Kind + "." + CRDGroupVersion.String()
	SpanContextPropagation_GroupVersionKind = CRDGroupVersion.WithKind(SpanContextPropagation_Kind)
)

func init() {
	SchemeBuilder.Register(&SpanContextPropagation{}, &SpanContextPropagationList{})
}

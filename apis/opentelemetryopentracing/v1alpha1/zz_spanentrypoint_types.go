// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type SpanEntryPointInitParameters struct {

	// (String) Whether to create an entry point or not
	// Whether to create an entry point or not
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Matches []SpanEntryPointMatchesInitParameters `json:"matches,omitempty" tf:"matches,omitempty"`

	// (String) The name of the rule
	// The name of the rule
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SpanEntryPointMatchesInitParameters struct {

	// (Block List, Min: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Match []SpanEntryPointMatchesMatchInitParameters `json:"match,omitempty" tf:"match,omitempty"`
}

type SpanEntryPointMatchesMatchInitParameters struct {

	// (Boolean) Whether to match strings case sensitively or not
	// Whether to match strings case sensitively or not
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Possible values are EQUALS, CONTAINS, STARTS_WITH, ENDS_WITH, DOES_NOT_EQUAL, DOES_NOT_CONTAIN, DOES_NOT_START_WITH and DOES_NOT_END_WITH.
	// Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
	Comparison *string `json:"comparison,omitempty" tf:"comparison,omitempty"`

	// (String) The name of the attribute if source is ATTRIBUTE
	// The name of the attribute if `source` is `ATTRIBUTE`
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) What to match against. Possible values are SPAN_NAME, SPAN_KIND, ATTRIBUTE, INSTRUMENTATION_LIBRARY_NAME and INSTRUMENTATION_LIBRARY_VERSION
	// What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// (String) The value to compare against. When source is SPAN_KIND the only allowed values are INTERNAL, SERVER, CLIENT, PRODUCER and CONSUMER
	// The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SpanEntryPointMatchesMatchObservation struct {

	// (Boolean) Whether to match strings case sensitively or not
	// Whether to match strings case sensitively or not
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Possible values are EQUALS, CONTAINS, STARTS_WITH, ENDS_WITH, DOES_NOT_EQUAL, DOES_NOT_CONTAIN, DOES_NOT_START_WITH and DOES_NOT_END_WITH.
	// Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
	Comparison *string `json:"comparison,omitempty" tf:"comparison,omitempty"`

	// (String) The name of the attribute if source is ATTRIBUTE
	// The name of the attribute if `source` is `ATTRIBUTE`
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) What to match against. Possible values are SPAN_NAME, SPAN_KIND, ATTRIBUTE, INSTRUMENTATION_LIBRARY_NAME and INSTRUMENTATION_LIBRARY_VERSION
	// What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// (String) The value to compare against. When source is SPAN_KIND the only allowed values are INTERNAL, SERVER, CLIENT, PRODUCER and CONSUMER
	// The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SpanEntryPointMatchesMatchParameters struct {

	// (Boolean) Whether to match strings case sensitively or not
	// Whether to match strings case sensitively or not
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Possible values are EQUALS, CONTAINS, STARTS_WITH, ENDS_WITH, DOES_NOT_EQUAL, DOES_NOT_CONTAIN, DOES_NOT_START_WITH and DOES_NOT_END_WITH.
	// Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
	// +kubebuilder:validation:Optional
	Comparison *string `json:"comparison" tf:"comparison,omitempty"`

	// (String) The name of the attribute if source is ATTRIBUTE
	// The name of the attribute if `source` is `ATTRIBUTE`
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) What to match against. Possible values are SPAN_NAME, SPAN_KIND, ATTRIBUTE, INSTRUMENTATION_LIBRARY_NAME and INSTRUMENTATION_LIBRARY_VERSION
	// What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
	// +kubebuilder:validation:Optional
	Source *string `json:"source" tf:"source,omitempty"`

	// (String) The value to compare against. When source is SPAN_KIND the only allowed values are INTERNAL, SERVER, CLIENT, PRODUCER and CONSUMER
	// The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SpanEntryPointMatchesObservation struct {

	// (Block List, Min: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Match []SpanEntryPointMatchesMatchObservation `json:"match,omitempty" tf:"match,omitempty"`
}

type SpanEntryPointMatchesParameters struct {

	// (Block List, Min: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	// +kubebuilder:validation:Optional
	Match []SpanEntryPointMatchesMatchParameters `json:"match" tf:"match,omitempty"`
}

type SpanEntryPointObservation struct {

	// (String) Whether to create an entry point or not
	// Whether to create an entry point or not
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	Matches []SpanEntryPointMatchesObservation `json:"matches,omitempty" tf:"matches,omitempty"`

	// (String) The name of the rule
	// The name of the rule
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SpanEntryPointParameters struct {

	// (String) Whether to create an entry point or not
	// Whether to create an entry point or not
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Matching strategies for the Span (see below for nested schema)
	// Matching strategies for the Span
	// +kubebuilder:validation:Optional
	Matches []SpanEntryPointMatchesParameters `json:"matches,omitempty" tf:"matches,omitempty"`

	// (String) The name of the rule
	// The name of the rule
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

// SpanEntryPointSpec defines the desired state of SpanEntryPoint
type SpanEntryPointSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SpanEntryPointParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SpanEntryPointInitParameters `json:"initProvider,omitempty"`
}

// SpanEntryPointStatus defines the observed state of SpanEntryPoint.
type SpanEntryPointStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SpanEntryPointObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SpanEntryPoint is the Schema for the SpanEntryPoints API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type SpanEntryPoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.action) || (has(self.initProvider) && has(self.initProvider.action))",message="spec.forProvider.action is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.matches) || (has(self.initProvider) && has(self.initProvider.matches))",message="spec.forProvider.matches is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   SpanEntryPointSpec   `json:"spec"`
	Status SpanEntryPointStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SpanEntryPointList contains a list of SpanEntryPoints
type SpanEntryPointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SpanEntryPoint `json:"items"`
}

// Repository type metadata.
var (
	SpanEntryPoint_Kind             = "SpanEntryPoint"
	SpanEntryPoint_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SpanEntryPoint_Kind}.String()
	SpanEntryPoint_KindAPIVersion   = SpanEntryPoint_Kind + "." + CRDGroupVersion.String()
	SpanEntryPoint_GroupVersionKind = CRDGroupVersion.WithKind(SpanEntryPoint_Kind)
)

func init() {
	SchemeBuilder.Register(&SpanEntryPoint{}, &SpanEntryPointList{})
}

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CustomAppEnablementInitParameters struct {

	// (Block List, Min: 1, Max: 1) Capture and analyze all user actions within your application. Enable Real User Monitoring (RUM) to monitor and improve your application's performance, identify errors, and gain insight into your user's behavior and experience. (see below for nested schema)
	// Capture and analyze all user actions within your application. Enable [Real User Monitoring (RUM)](https://dt-url.net/1n2b0prq) to monitor and improve your application's performance, identify errors, and gain insight into your user's behavior and experience.
	Rum []RumInitParameters `json:"rum,omitempty" tf:"rum,omitempty"`

	// (String) The scope of this setting (CUSTOM_APPLICATION). Omit this property if you want to cover the whole environment.
	// The scope of this setting (CUSTOM_APPLICATION). Omit this property if you want to cover the whole environment.
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type CustomAppEnablementObservation struct {

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Block List, Min: 1, Max: 1) Capture and analyze all user actions within your application. Enable Real User Monitoring (RUM) to monitor and improve your application's performance, identify errors, and gain insight into your user's behavior and experience. (see below for nested schema)
	// Capture and analyze all user actions within your application. Enable [Real User Monitoring (RUM)](https://dt-url.net/1n2b0prq) to monitor and improve your application's performance, identify errors, and gain insight into your user's behavior and experience.
	Rum []RumObservation `json:"rum,omitempty" tf:"rum,omitempty"`

	// (String) The scope of this setting (CUSTOM_APPLICATION). Omit this property if you want to cover the whole environment.
	// The scope of this setting (CUSTOM_APPLICATION). Omit this property if you want to cover the whole environment.
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type CustomAppEnablementParameters struct {

	// (Block List, Min: 1, Max: 1) Capture and analyze all user actions within your application. Enable Real User Monitoring (RUM) to monitor and improve your application's performance, identify errors, and gain insight into your user's behavior and experience. (see below for nested schema)
	// Capture and analyze all user actions within your application. Enable [Real User Monitoring (RUM)](https://dt-url.net/1n2b0prq) to monitor and improve your application's performance, identify errors, and gain insight into your user's behavior and experience.
	// +kubebuilder:validation:Optional
	Rum []RumParameters `json:"rum,omitempty" tf:"rum,omitempty"`

	// (String) The scope of this setting (CUSTOM_APPLICATION). Omit this property if you want to cover the whole environment.
	// The scope of this setting (CUSTOM_APPLICATION). Omit this property if you want to cover the whole environment.
	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type RumInitParameters struct {

	// action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
	// (Field has overlap with `dynatrace_mobile_application`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your application’s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
	CostAndTrafficControl *float64 `json:"costAndTrafficControl,omitempty" tf:"cost_and_traffic_control,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type RumObservation struct {

	// action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
	// (Field has overlap with `dynatrace_mobile_application`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your application’s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
	CostAndTrafficControl *float64 `json:"costAndTrafficControl,omitempty" tf:"cost_and_traffic_control,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type RumParameters struct {

	// action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
	// (Field has overlap with `dynatrace_mobile_application`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your application’s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
	// +kubebuilder:validation:Optional
	CostAndTrafficControl *float64 `json:"costAndTrafficControl" tf:"cost_and_traffic_control,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`
}

// CustomAppEnablementSpec defines the desired state of CustomAppEnablement
type CustomAppEnablementSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CustomAppEnablementParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider CustomAppEnablementInitParameters `json:"initProvider,omitempty"`
}

// CustomAppEnablementStatus defines the observed state of CustomAppEnablement.
type CustomAppEnablementStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CustomAppEnablementObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// CustomAppEnablement is the Schema for the CustomAppEnablements API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type CustomAppEnablement struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.rum) || (has(self.initProvider) && has(self.initProvider.rum))",message="spec.forProvider.rum is a required parameter"
	Spec   CustomAppEnablementSpec   `json:"spec"`
	Status CustomAppEnablementStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CustomAppEnablementList contains a list of CustomAppEnablements
type CustomAppEnablementList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []CustomAppEnablement `json:"items"`
}

// Repository type metadata.
var (
	CustomAppEnablement_Kind             = "CustomAppEnablement"
	CustomAppEnablement_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: CustomAppEnablement_Kind}.String()
	CustomAppEnablement_KindAPIVersion   = CustomAppEnablement_Kind + "." + CRDGroupVersion.String()
	CustomAppEnablement_GroupVersionKind = CRDGroupVersion.WithKind(CustomAppEnablement_Kind)
)

func init() {
	SchemeBuilder.Register(&CustomAppEnablement{}, &CustomAppEnablementList{})
}

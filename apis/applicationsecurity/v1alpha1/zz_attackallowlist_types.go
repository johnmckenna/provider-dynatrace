// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AttackAllowlistInitParameters struct {

	// (Block List, Min: 1, Max: 1) Step 2: Define attack control for chosen criteria (see below for nested schema)
	// Step 2: Define attack control for chosen criteria
	AttackHandling []AttackHandlingInitParameters `json:"attackHandling,omitempty" tf:"attack_handling,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 1: Define criteria. Please specify at least one of source IP or attack pattern. (see below for nested schema)
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	Criteria []CriteriaInitParameters `json:"criteria,omitempty" tf:"criteria,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 3: Leave comment (see below for nested schema)
	// Step 3: Leave comment
	Metadata []MetadataInitParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`
}

type AttackAllowlistObservation struct {

	// (Block List, Min: 1, Max: 1) Step 2: Define attack control for chosen criteria (see below for nested schema)
	// Step 2: Define attack control for chosen criteria
	AttackHandling []AttackHandlingObservation `json:"attackHandling,omitempty" tf:"attack_handling,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 1: Define criteria. Please specify at least one of source IP or attack pattern. (see below for nested schema)
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	Criteria []CriteriaObservation `json:"criteria,omitempty" tf:"criteria,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 3: Leave comment (see below for nested schema)
	// Step 3: Leave comment
	Metadata []MetadataObservation `json:"metadata,omitempty" tf:"metadata,omitempty"`
}

type AttackAllowlistParameters struct {

	// (Block List, Min: 1, Max: 1) Step 2: Define attack control for chosen criteria (see below for nested schema)
	// Step 2: Define attack control for chosen criteria
	// +kubebuilder:validation:Optional
	AttackHandling []AttackHandlingParameters `json:"attackHandling,omitempty" tf:"attack_handling,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 1: Define criteria. Please specify at least one of source IP or attack pattern. (see below for nested schema)
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	// +kubebuilder:validation:Optional
	Criteria []CriteriaParameters `json:"criteria,omitempty" tf:"criteria,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 3: Leave comment (see below for nested schema)
	// Step 3: Leave comment
	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`
}

type AttackHandlingInitParameters struct {

	// (String) Possible Values: MONITOR, OFF
	// Possible Values: `MONITOR`, `OFF`
	BlockingStrategy *string `json:"blockingStrategy,omitempty" tf:"blocking_strategy,omitempty"`
}

type AttackHandlingObservation struct {

	// (String) Possible Values: MONITOR, OFF
	// Possible Values: `MONITOR`, `OFF`
	BlockingStrategy *string `json:"blockingStrategy,omitempty" tf:"blocking_strategy,omitempty"`
}

type AttackHandlingParameters struct {

	// (String) Possible Values: MONITOR, OFF
	// Possible Values: `MONITOR`, `OFF`
	// +kubebuilder:validation:Optional
	BlockingStrategy *string `json:"blockingStrategy" tf:"blocking_strategy,omitempty"`
}

type CriteriaInitParameters struct {

	// (String) Only consider attacks matching the specified pattern.
	// Only consider attacks matching the specified pattern.
	AttackPattern *string `json:"attackPattern,omitempty" tf:"attack_pattern,omitempty"`

	// (String) Source IP
	// Source IP
	SourceIP *string `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type CriteriaObservation struct {

	// (String) Only consider attacks matching the specified pattern.
	// Only consider attacks matching the specified pattern.
	AttackPattern *string `json:"attackPattern,omitempty" tf:"attack_pattern,omitempty"`

	// (String) Source IP
	// Source IP
	SourceIP *string `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type CriteriaParameters struct {

	// (String) Only consider attacks matching the specified pattern.
	// Only consider attacks matching the specified pattern.
	// +kubebuilder:validation:Optional
	AttackPattern *string `json:"attackPattern,omitempty" tf:"attack_pattern,omitempty"`

	// (String) Source IP
	// Source IP
	// +kubebuilder:validation:Optional
	SourceIP *string `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type MetadataInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`
}

type MetadataObservation struct {

	// (String) no documentation available
	// no documentation available
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`
}

type MetadataParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment" tf:"comment,omitempty"`
}

// AttackAllowlistSpec defines the desired state of AttackAllowlist
type AttackAllowlistSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AttackAllowlistParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AttackAllowlistInitParameters `json:"initProvider,omitempty"`
}

// AttackAllowlistStatus defines the observed state of AttackAllowlist.
type AttackAllowlistStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AttackAllowlistObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// AttackAllowlist is the Schema for the AttackAllowlists API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type AttackAllowlist struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.attackHandling) || (has(self.initProvider) && has(self.initProvider.attackHandling))",message="spec.forProvider.attackHandling is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.criteria) || (has(self.initProvider) && has(self.initProvider.criteria))",message="spec.forProvider.criteria is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.metadata) || (has(self.initProvider) && has(self.initProvider.metadata))",message="spec.forProvider.metadata is a required parameter"
	Spec   AttackAllowlistSpec   `json:"spec"`
	Status AttackAllowlistStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AttackAllowlistList contains a list of AttackAllowlists
type AttackAllowlistList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AttackAllowlist `json:"items"`
}

// Repository type metadata.
var (
	AttackAllowlist_Kind             = "AttackAllowlist"
	AttackAllowlist_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AttackAllowlist_Kind}.String()
	AttackAllowlist_KindAPIVersion   = AttackAllowlist_Kind + "." + CRDGroupVersion.String()
	AttackAllowlist_GroupVersionKind = CRDGroupVersion.WithKind(AttackAllowlist_Kind)
)

func init() {
	SchemeBuilder.Register(&AttackAllowlist{}, &AttackAllowlistList{})
}

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AttackRulesAttackHandlingInitParameters struct {

	// (String) Possible Values: BLOCK, MONITOR, OFF
	// Possible Values: `BLOCK`, `MONITOR`, `OFF`
	BlockingStrategy *string `json:"blockingStrategy,omitempty" tf:"blocking_strategy,omitempty"`
}

type AttackRulesAttackHandlingObservation struct {

	// (String) Possible Values: BLOCK, MONITOR, OFF
	// Possible Values: `BLOCK`, `MONITOR`, `OFF`
	BlockingStrategy *string `json:"blockingStrategy,omitempty" tf:"blocking_strategy,omitempty"`
}

type AttackRulesAttackHandlingParameters struct {

	// (String) Possible Values: BLOCK, MONITOR, OFF
	// Possible Values: `BLOCK`, `MONITOR`, `OFF`
	// +kubebuilder:validation:Optional
	BlockingStrategy *string `json:"blockingStrategy" tf:"blocking_strategy,omitempty"`
}

type AttackRulesCriteriaInitParameters struct {

	// (String) Possible Values: ANY, CMD_INJECTION, JNDI_INJECTION, SQL_INJECTION, SSRF
	// Possible Values: `ANY`, `CMD_INJECTION`, `JNDI_INJECTION`, `SQL_INJECTION`, `SSRF`
	AttackType *string `json:"attackType,omitempty" tf:"attack_type,omitempty"`

	// (String, Deprecated) Process group
	// Process group
	ProcessGroup *string `json:"processGroup,omitempty" tf:"process_group,omitempty"`
}

type AttackRulesCriteriaObservation struct {

	// (String) Possible Values: ANY, CMD_INJECTION, JNDI_INJECTION, SQL_INJECTION, SSRF
	// Possible Values: `ANY`, `CMD_INJECTION`, `JNDI_INJECTION`, `SQL_INJECTION`, `SSRF`
	AttackType *string `json:"attackType,omitempty" tf:"attack_type,omitempty"`

	// (String, Deprecated) Process group
	// Process group
	ProcessGroup *string `json:"processGroup,omitempty" tf:"process_group,omitempty"`
}

type AttackRulesCriteriaParameters struct {

	// (String) Possible Values: ANY, CMD_INJECTION, JNDI_INJECTION, SQL_INJECTION, SSRF
	// Possible Values: `ANY`, `CMD_INJECTION`, `JNDI_INJECTION`, `SQL_INJECTION`, `SSRF`
	// +kubebuilder:validation:Optional
	AttackType *string `json:"attackType" tf:"attack_type,omitempty"`

	// (String, Deprecated) Process group
	// Process group
	// +kubebuilder:validation:Optional
	ProcessGroup *string `json:"processGroup,omitempty" tf:"process_group,omitempty"`
}

type AttackRulesInitParameters struct {

	// (Block List, Min: 1, Max: 1) Step 1: Select attack protection behavior (see below for nested schema)
	// Step 1: Select attack protection behavior
	AttackHandling []AttackRulesAttackHandlingInitParameters `json:"attackHandling,omitempty" tf:"attack_handling,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 2: Select attack type (see below for nested schema)
	// Step 2: Select attack type
	Criteria []AttackRulesCriteriaInitParameters `json:"criteria,omitempty" tf:"criteria,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 4: Leave comment  (see below for nested schema)
	// Step 4: Leave comment (optional)
	Metadata []AttackRulesMetadataInitParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Block List, Max: 1) If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	//
	// We provide suggestions for resource attribute keys and values based on what we currently see in your environment. You can also enter any value not currently seen in the list. Resource attributes come out of the box from the OneAgent, and you can set them up from [data enrichment](https://docs.dynatrace.com/docs/extend-dynatrace/extend-data).
	ResourceAttributeConditions []ResourceAttributeConditionsInitParameters `json:"resourceAttributeConditions,omitempty" tf:"resource_attribute_conditions,omitempty"`

	// (String) Rule name
	// Rule name
	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`
}

type AttackRulesMetadataInitParameters struct {

	// (String) no documentation available
	// no documentation available
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`
}

type AttackRulesMetadataObservation struct {

	// (String) no documentation available
	// no documentation available
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`
}

type AttackRulesMetadataParameters struct {

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment" tf:"comment,omitempty"`
}

type AttackRulesObservation struct {

	// (Block List, Min: 1, Max: 1) Step 1: Select attack protection behavior (see below for nested schema)
	// Step 1: Select attack protection behavior
	AttackHandling []AttackRulesAttackHandlingObservation `json:"attackHandling,omitempty" tf:"attack_handling,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 2: Select attack type (see below for nested schema)
	// Step 2: Select attack type
	Criteria []AttackRulesCriteriaObservation `json:"criteria,omitempty" tf:"criteria,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 4: Leave comment  (see below for nested schema)
	// Step 4: Leave comment (optional)
	Metadata []AttackRulesMetadataObservation `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Block List, Max: 1) If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	//
	// We provide suggestions for resource attribute keys and values based on what we currently see in your environment. You can also enter any value not currently seen in the list. Resource attributes come out of the box from the OneAgent, and you can set them up from [data enrichment](https://docs.dynatrace.com/docs/extend-dynatrace/extend-data).
	ResourceAttributeConditions []ResourceAttributeConditionsObservation `json:"resourceAttributeConditions,omitempty" tf:"resource_attribute_conditions,omitempty"`

	// (String) Rule name
	// Rule name
	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`
}

type AttackRulesParameters struct {

	// (Block List, Min: 1, Max: 1) Step 1: Select attack protection behavior (see below for nested schema)
	// Step 1: Select attack protection behavior
	// +kubebuilder:validation:Optional
	AttackHandling []AttackRulesAttackHandlingParameters `json:"attackHandling,omitempty" tf:"attack_handling,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 2: Select attack type (see below for nested schema)
	// Step 2: Select attack type
	// +kubebuilder:validation:Optional
	Criteria []AttackRulesCriteriaParameters `json:"criteria,omitempty" tf:"criteria,omitempty"`

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// (Block List, Min: 1, Max: 1) Step 4: Leave comment  (see below for nested schema)
	// Step 4: Leave comment (optional)
	// +kubebuilder:validation:Optional
	Metadata []AttackRulesMetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Block List, Max: 1) If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	//
	// We provide suggestions for resource attribute keys and values based on what we currently see in your environment. You can also enter any value not currently seen in the list. Resource attributes come out of the box from the OneAgent, and you can set them up from [data enrichment](https://docs.dynatrace.com/docs/extend-dynatrace/extend-data).
	// +kubebuilder:validation:Optional
	ResourceAttributeConditions []ResourceAttributeConditionsParameters `json:"resourceAttributeConditions,omitempty" tf:"resource_attribute_conditions,omitempty"`

	// (String) Rule name
	// Rule name
	// +kubebuilder:validation:Optional
	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`
}

type ResourceAttributeConditionInitParameters struct {

	// (String) Possible Values: CONTAINS, DOES_NOT_CONTAIN, DOES_NOT_END_WITH, DOES_NOT_EXIST, DOES_NOT_START_WITH, ENDS_WITH, EQUALS, EXISTS, NOT_EQUALS, STARTS_WITH
	// Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_END_WITH`, `DOES_NOT_EXIST`, `DOES_NOT_START_WITH`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `NOT_EQUALS`, `STARTS_WITH`
	Matcher *string `json:"matcher,omitempty" tf:"matcher,omitempty"`

	// (String) Resource attribute key
	// Resource attribute key
	ResourceAttributeKey *string `json:"resourceAttributeKey,omitempty" tf:"resource_attribute_key,omitempty"`

	// (String) Resource attribute value
	// Resource attribute value
	ResourceAttributeValue *string `json:"resourceAttributeValue,omitempty" tf:"resource_attribute_value,omitempty"`
}

type ResourceAttributeConditionObservation struct {

	// (String) Possible Values: CONTAINS, DOES_NOT_CONTAIN, DOES_NOT_END_WITH, DOES_NOT_EXIST, DOES_NOT_START_WITH, ENDS_WITH, EQUALS, EXISTS, NOT_EQUALS, STARTS_WITH
	// Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_END_WITH`, `DOES_NOT_EXIST`, `DOES_NOT_START_WITH`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `NOT_EQUALS`, `STARTS_WITH`
	Matcher *string `json:"matcher,omitempty" tf:"matcher,omitempty"`

	// (String) Resource attribute key
	// Resource attribute key
	ResourceAttributeKey *string `json:"resourceAttributeKey,omitempty" tf:"resource_attribute_key,omitempty"`

	// (String) Resource attribute value
	// Resource attribute value
	ResourceAttributeValue *string `json:"resourceAttributeValue,omitempty" tf:"resource_attribute_value,omitempty"`
}

type ResourceAttributeConditionParameters struct {

	// (String) Possible Values: CONTAINS, DOES_NOT_CONTAIN, DOES_NOT_END_WITH, DOES_NOT_EXIST, DOES_NOT_START_WITH, ENDS_WITH, EQUALS, EXISTS, NOT_EQUALS, STARTS_WITH
	// Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_END_WITH`, `DOES_NOT_EXIST`, `DOES_NOT_START_WITH`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `NOT_EQUALS`, `STARTS_WITH`
	// +kubebuilder:validation:Optional
	Matcher *string `json:"matcher" tf:"matcher,omitempty"`

	// (String) Resource attribute key
	// Resource attribute key
	// +kubebuilder:validation:Optional
	ResourceAttributeKey *string `json:"resourceAttributeKey" tf:"resource_attribute_key,omitempty"`

	// (String) Resource attribute value
	// Resource attribute value
	// +kubebuilder:validation:Optional
	ResourceAttributeValue *string `json:"resourceAttributeValue,omitempty" tf:"resource_attribute_value,omitempty"`
}

type ResourceAttributeConditionsInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	ResourceAttributeCondition []ResourceAttributeConditionInitParameters `json:"resourceAttributeCondition,omitempty" tf:"resource_attribute_condition,omitempty"`
}

type ResourceAttributeConditionsObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	ResourceAttributeCondition []ResourceAttributeConditionObservation `json:"resourceAttributeCondition,omitempty" tf:"resource_attribute_condition,omitempty"`
}

type ResourceAttributeConditionsParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	ResourceAttributeCondition []ResourceAttributeConditionParameters `json:"resourceAttributeCondition" tf:"resource_attribute_condition,omitempty"`
}

// AttackRulesSpec defines the desired state of AttackRules
type AttackRulesSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AttackRulesParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AttackRulesInitParameters `json:"initProvider,omitempty"`
}

// AttackRulesStatus defines the observed state of AttackRules.
type AttackRulesStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AttackRulesObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// AttackRules is the Schema for the AttackRuless API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type AttackRules struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.attackHandling) || (has(self.initProvider) && has(self.initProvider.attackHandling))",message="spec.forProvider.attackHandling is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.criteria) || (has(self.initProvider) && has(self.initProvider.criteria))",message="spec.forProvider.criteria is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.metadata) || (has(self.initProvider) && has(self.initProvider.metadata))",message="spec.forProvider.metadata is a required parameter"
	Spec   AttackRulesSpec   `json:"spec"`
	Status AttackRulesStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AttackRulesList contains a list of AttackRuless
type AttackRulesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AttackRules `json:"items"`
}

// Repository type metadata.
var (
	AttackRules_Kind             = "AttackRules"
	AttackRules_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AttackRules_Kind}.String()
	AttackRules_KindAPIVersion   = AttackRules_Kind + "." + CRDGroupVersion.String()
	AttackRules_GroupVersionKind = CRDGroupVersion.WithKind(AttackRules_Kind)
)

func init() {
	SchemeBuilder.Register(&AttackRules{}, &AttackRulesList{})
}

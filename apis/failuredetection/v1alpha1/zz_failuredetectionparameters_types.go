// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BrokenLinksInitParameters struct {

	// (Set of String) If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
	// If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
	// +listType=set
	BrokenLinkDomains []*string `json:"brokenLinkDomains,omitempty" tf:"broken_link_domains,omitempty"`

	// (Boolean) Consider 404 HTTP response codes as failures
	// Consider 404 HTTP response codes as failures
	HTTP404NotFoundFailures *bool `json:"http404NotFoundFailures,omitempty" tf:"http_404_not_found_failures,omitempty"`
}

type BrokenLinksObservation struct {

	// (Set of String) If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
	// If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
	// +listType=set
	BrokenLinkDomains []*string `json:"brokenLinkDomains,omitempty" tf:"broken_link_domains,omitempty"`

	// (Boolean) Consider 404 HTTP response codes as failures
	// Consider 404 HTTP response codes as failures
	HTTP404NotFoundFailures *bool `json:"http404NotFoundFailures,omitempty" tf:"http_404_not_found_failures,omitempty"`
}

type BrokenLinksParameters struct {

	// (Set of String) If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
	// If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
	// +kubebuilder:validation:Optional
	// +listType=set
	BrokenLinkDomains []*string `json:"brokenLinkDomains,omitempty" tf:"broken_link_domains,omitempty"`

	// (Boolean) Consider 404 HTTP response codes as failures
	// Consider 404 HTTP response codes as failures
	// +kubebuilder:validation:Optional
	HTTP404NotFoundFailures *bool `json:"http404NotFoundFailures" tf:"http_404_not_found_failures,omitempty"`
}

type ConditionInitParameters struct {

	// (Boolean) Case sensitive
	// Case sensitive
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Apply this comparison
	// Apply this comparison
	CompareOperationType *string `json:"compareOperationType,omitempty" tf:"compare_operation_type,omitempty"`

	// (Number) Value
	// Value
	DoubleValue *float64 `json:"doubleValue,omitempty" tf:"double_value,omitempty"`

	// (Number) Value
	// Value
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (String) Value
	// Value
	TextValue *string `json:"textValue,omitempty" tf:"text_value,omitempty"`
}

type ConditionObservation struct {

	// (Boolean) Case sensitive
	// Case sensitive
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Apply this comparison
	// Apply this comparison
	CompareOperationType *string `json:"compareOperationType,omitempty" tf:"compare_operation_type,omitempty"`

	// (Number) Value
	// Value
	DoubleValue *float64 `json:"doubleValue,omitempty" tf:"double_value,omitempty"`

	// (Number) Value
	// Value
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (String) Value
	// Value
	TextValue *string `json:"textValue,omitempty" tf:"text_value,omitempty"`
}

type ConditionParameters struct {

	// (Boolean) Case sensitive
	// Case sensitive
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// (String) Apply this comparison
	// Apply this comparison
	// +kubebuilder:validation:Optional
	CompareOperationType *string `json:"compareOperationType" tf:"compare_operation_type,omitempty"`

	// (Number) Value
	// Value
	// +kubebuilder:validation:Optional
	DoubleValue *float64 `json:"doubleValue,omitempty" tf:"double_value,omitempty"`

	// (Number) Value
	// Value
	// +kubebuilder:validation:Optional
	IntValue *float64 `json:"intValue,omitempty" tf:"int_value,omitempty"`

	// (String) Value
	// Value
	// +kubebuilder:validation:Optional
	TextValue *string `json:"textValue,omitempty" tf:"text_value,omitempty"`
}

type CustomErrorRuleInitParameters struct {

	// (Block List, Min: 1, Max: 1) Request attribute condition (see below for nested schema)
	// Request attribute condition
	Condition []ConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// (String) Request attribute
	// Request attribute
	RequestAttribute *string `json:"requestAttribute,omitempty" tf:"request_attribute,omitempty"`
}

type CustomErrorRuleObservation struct {

	// (Block List, Min: 1, Max: 1) Request attribute condition (see below for nested schema)
	// Request attribute condition
	Condition []ConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`

	// (String) Request attribute
	// Request attribute
	RequestAttribute *string `json:"requestAttribute,omitempty" tf:"request_attribute,omitempty"`
}

type CustomErrorRuleParameters struct {

	// (Block List, Min: 1, Max: 1) Request attribute condition (see below for nested schema)
	// Request attribute condition
	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition" tf:"condition,omitempty"`

	// (String) Request attribute
	// Request attribute
	// +kubebuilder:validation:Optional
	RequestAttribute *string `json:"requestAttribute" tf:"request_attribute,omitempty"`
}

type CustomErrorRulesInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomErrorRule []CustomErrorRuleInitParameters `json:"customErrorRule,omitempty" tf:"custom_error_rule,omitempty"`
}

type CustomErrorRulesObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomErrorRule []CustomErrorRuleObservation `json:"customErrorRule,omitempty" tf:"custom_error_rule,omitempty"`
}

type CustomErrorRulesParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CustomErrorRule []CustomErrorRuleParameters `json:"customErrorRule" tf:"custom_error_rule,omitempty"`
}

type CustomHandledExceptionInitParameters struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type CustomHandledExceptionObservation struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type CustomHandledExceptionParameters struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	// +kubebuilder:validation:Optional
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// +kubebuilder:validation:Optional
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type CustomHandledExceptionsInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomHandledException []CustomHandledExceptionInitParameters `json:"customHandledException,omitempty" tf:"custom_handled_exception,omitempty"`
}

type CustomHandledExceptionsObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomHandledException []CustomHandledExceptionObservation `json:"customHandledException,omitempty" tf:"custom_handled_exception,omitempty"`
}

type CustomHandledExceptionsParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CustomHandledException []CustomHandledExceptionParameters `json:"customHandledException" tf:"custom_handled_exception,omitempty"`
}

type ExceptionRulesInitParameters struct {

	// (Block List, Max: 1) Some custom error situations are only detectable via a return value or other means. To support such cases, define a request attribute that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute. (see below for nested schema)
	// Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
	CustomErrorRules []CustomErrorRulesInitParameters `json:"customErrorRules,omitempty" tf:"custom_error_rules,omitempty"`

	// handled exceptions that should be treated as service failures. (see below for nested schema)
	// There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
	CustomHandledExceptions []CustomHandledExceptionsInitParameters `json:"customHandledExceptions,omitempty" tf:"custom_handled_exceptions,omitempty"`

	// (Boolean) Ignore all exceptions
	// Ignore all exceptions
	IgnoreAllExceptions *bool `json:"ignoreAllExceptions,omitempty" tf:"ignore_all_exceptions,omitempty"`

	// (Boolean) Ignore span failure detection
	// Ignore span failure detection
	IgnoreSpanFailureDetection *bool `json:"ignoreSpanFailureDetection,omitempty" tf:"ignore_span_failure_detection,omitempty"`

	// party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed. (see below for nested schema)
	// Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
	IgnoredExceptions []IgnoredExceptionsInitParameters `json:"ignoredExceptions,omitempty" tf:"ignored_exceptions,omitempty"`

	// (Block List, Max: 1) Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request. (see below for nested schema)
	// Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
	SuccessForcingExceptions []SuccessForcingExceptionsInitParameters `json:"successForcingExceptions,omitempty" tf:"success_forcing_exceptions,omitempty"`
}

type ExceptionRulesObservation struct {

	// (Block List, Max: 1) Some custom error situations are only detectable via a return value or other means. To support such cases, define a request attribute that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute. (see below for nested schema)
	// Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
	CustomErrorRules []CustomErrorRulesObservation `json:"customErrorRules,omitempty" tf:"custom_error_rules,omitempty"`

	// handled exceptions that should be treated as service failures. (see below for nested schema)
	// There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
	CustomHandledExceptions []CustomHandledExceptionsObservation `json:"customHandledExceptions,omitempty" tf:"custom_handled_exceptions,omitempty"`

	// (Boolean) Ignore all exceptions
	// Ignore all exceptions
	IgnoreAllExceptions *bool `json:"ignoreAllExceptions,omitempty" tf:"ignore_all_exceptions,omitempty"`

	// (Boolean) Ignore span failure detection
	// Ignore span failure detection
	IgnoreSpanFailureDetection *bool `json:"ignoreSpanFailureDetection,omitempty" tf:"ignore_span_failure_detection,omitempty"`

	// party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed. (see below for nested schema)
	// Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
	IgnoredExceptions []IgnoredExceptionsObservation `json:"ignoredExceptions,omitempty" tf:"ignored_exceptions,omitempty"`

	// (Block List, Max: 1) Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request. (see below for nested schema)
	// Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
	SuccessForcingExceptions []SuccessForcingExceptionsObservation `json:"successForcingExceptions,omitempty" tf:"success_forcing_exceptions,omitempty"`
}

type ExceptionRulesParameters struct {

	// (Block List, Max: 1) Some custom error situations are only detectable via a return value or other means. To support such cases, define a request attribute that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute. (see below for nested schema)
	// Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
	// +kubebuilder:validation:Optional
	CustomErrorRules []CustomErrorRulesParameters `json:"customErrorRules,omitempty" tf:"custom_error_rules,omitempty"`

	// handled exceptions that should be treated as service failures. (see below for nested schema)
	// There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
	// +kubebuilder:validation:Optional
	CustomHandledExceptions []CustomHandledExceptionsParameters `json:"customHandledExceptions,omitempty" tf:"custom_handled_exceptions,omitempty"`

	// (Boolean) Ignore all exceptions
	// Ignore all exceptions
	// +kubebuilder:validation:Optional
	IgnoreAllExceptions *bool `json:"ignoreAllExceptions" tf:"ignore_all_exceptions,omitempty"`

	// (Boolean) Ignore span failure detection
	// Ignore span failure detection
	// +kubebuilder:validation:Optional
	IgnoreSpanFailureDetection *bool `json:"ignoreSpanFailureDetection" tf:"ignore_span_failure_detection,omitempty"`

	// party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed. (see below for nested schema)
	// Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
	// +kubebuilder:validation:Optional
	IgnoredExceptions []IgnoredExceptionsParameters `json:"ignoredExceptions,omitempty" tf:"ignored_exceptions,omitempty"`

	// (Block List, Max: 1) Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request. (see below for nested schema)
	// Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
	// +kubebuilder:validation:Optional
	SuccessForcingExceptions []SuccessForcingExceptionsParameters `json:"successForcingExceptions,omitempty" tf:"success_forcing_exceptions,omitempty"`
}

type FailureDetectionParametersInitParameters struct {

	// side service failures. (see below for nested schema)
	// HTTP 404 response codes are thrown when a web server can't find a certain page. 404s are classified as broken links on the client side and therefore aren't considered to be service failures. By enabling this setting, you can have 404s treated as server-side service failures.
	BrokenLinks []BrokenLinksInitParameters `json:"brokenLinks,omitempty" tf:"broken_links,omitempty"`

	// (String) Description
	// Description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Min: 1, Max: 1) Customize failure detection for specific exceptions and errors (see below for nested schema)
	// Customize failure detection for specific exceptions and errors
	ExceptionRules []ExceptionRulesInitParameters `json:"exceptionRules,omitempty" tf:"exception_rules,omitempty"`

	// (Block List, Min: 1, Max: 1) HTTP response codes (see below for nested schema)
	// HTTP response codes
	HTTPResponseCodes []HTTPResponseCodesInitParameters `json:"httpResponseCodes,omitempty" tf:"http_response_codes,omitempty"`

	// (String) Name
	// Name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type FailureDetectionParametersObservation struct {

	// side service failures. (see below for nested schema)
	// HTTP 404 response codes are thrown when a web server can't find a certain page. 404s are classified as broken links on the client side and therefore aren't considered to be service failures. By enabling this setting, you can have 404s treated as server-side service failures.
	BrokenLinks []BrokenLinksObservation `json:"brokenLinks,omitempty" tf:"broken_links,omitempty"`

	// (String) Description
	// Description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Min: 1, Max: 1) Customize failure detection for specific exceptions and errors (see below for nested schema)
	// Customize failure detection for specific exceptions and errors
	ExceptionRules []ExceptionRulesObservation `json:"exceptionRules,omitempty" tf:"exception_rules,omitempty"`

	// (Block List, Min: 1, Max: 1) HTTP response codes (see below for nested schema)
	// HTTP response codes
	HTTPResponseCodes []HTTPResponseCodesObservation `json:"httpResponseCodes,omitempty" tf:"http_response_codes,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Name
	// Name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type FailureDetectionParametersParameters struct {

	// side service failures. (see below for nested schema)
	// HTTP 404 response codes are thrown when a web server can't find a certain page. 404s are classified as broken links on the client side and therefore aren't considered to be service failures. By enabling this setting, you can have 404s treated as server-side service failures.
	// +kubebuilder:validation:Optional
	BrokenLinks []BrokenLinksParameters `json:"brokenLinks,omitempty" tf:"broken_links,omitempty"`

	// (String) Description
	// Description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Min: 1, Max: 1) Customize failure detection for specific exceptions and errors (see below for nested schema)
	// Customize failure detection for specific exceptions and errors
	// +kubebuilder:validation:Optional
	ExceptionRules []ExceptionRulesParameters `json:"exceptionRules,omitempty" tf:"exception_rules,omitempty"`

	// (Block List, Min: 1, Max: 1) HTTP response codes (see below for nested schema)
	// HTTP response codes
	// +kubebuilder:validation:Optional
	HTTPResponseCodes []HTTPResponseCodesParameters `json:"httpResponseCodes,omitempty" tf:"http_response_codes,omitempty"`

	// (String) Name
	// Name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type HTTPResponseCodesInitParameters struct {

	// (String) HTTP response codes which indicate client side errors
	// HTTP response codes which indicate client side errors
	ClientSideErrors *string `json:"clientSideErrors,omitempty" tf:"client_side_errors,omitempty"`

	// (Boolean) Treat missing HTTP response code as client side error
	// Treat missing HTTP response code as client side error
	FailOnMissingResponseCodeClientSide *bool `json:"failOnMissingResponseCodeClientSide,omitempty" tf:"fail_on_missing_response_code_client_side,omitempty"`

	// (Boolean) Treat missing HTTP response code as server side errors
	// Treat missing HTTP response code as server side errors
	FailOnMissingResponseCodeServerSide *bool `json:"failOnMissingResponseCodeServerSide,omitempty" tf:"fail_on_missing_response_code_server_side,omitempty"`

	// (String) HTTP response codes which indicate an error on the server side
	// HTTP response codes which indicate an error on the server side
	ServerSideErrors *string `json:"serverSideErrors,omitempty" tf:"server_side_errors,omitempty"`
}

type HTTPResponseCodesObservation struct {

	// (String) HTTP response codes which indicate client side errors
	// HTTP response codes which indicate client side errors
	ClientSideErrors *string `json:"clientSideErrors,omitempty" tf:"client_side_errors,omitempty"`

	// (Boolean) Treat missing HTTP response code as client side error
	// Treat missing HTTP response code as client side error
	FailOnMissingResponseCodeClientSide *bool `json:"failOnMissingResponseCodeClientSide,omitempty" tf:"fail_on_missing_response_code_client_side,omitempty"`

	// (Boolean) Treat missing HTTP response code as server side errors
	// Treat missing HTTP response code as server side errors
	FailOnMissingResponseCodeServerSide *bool `json:"failOnMissingResponseCodeServerSide,omitempty" tf:"fail_on_missing_response_code_server_side,omitempty"`

	// (String) HTTP response codes which indicate an error on the server side
	// HTTP response codes which indicate an error on the server side
	ServerSideErrors *string `json:"serverSideErrors,omitempty" tf:"server_side_errors,omitempty"`
}

type HTTPResponseCodesParameters struct {

	// (String) HTTP response codes which indicate client side errors
	// HTTP response codes which indicate client side errors
	// +kubebuilder:validation:Optional
	ClientSideErrors *string `json:"clientSideErrors" tf:"client_side_errors,omitempty"`

	// (Boolean) Treat missing HTTP response code as client side error
	// Treat missing HTTP response code as client side error
	// +kubebuilder:validation:Optional
	FailOnMissingResponseCodeClientSide *bool `json:"failOnMissingResponseCodeClientSide" tf:"fail_on_missing_response_code_client_side,omitempty"`

	// (Boolean) Treat missing HTTP response code as server side errors
	// Treat missing HTTP response code as server side errors
	// +kubebuilder:validation:Optional
	FailOnMissingResponseCodeServerSide *bool `json:"failOnMissingResponseCodeServerSide" tf:"fail_on_missing_response_code_server_side,omitempty"`

	// (String) HTTP response codes which indicate an error on the server side
	// HTTP response codes which indicate an error on the server side
	// +kubebuilder:validation:Optional
	ServerSideErrors *string `json:"serverSideErrors" tf:"server_side_errors,omitempty"`
}

type IgnoredExceptionsCustomHandledExceptionInitParameters struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type IgnoredExceptionsCustomHandledExceptionObservation struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type IgnoredExceptionsCustomHandledExceptionParameters struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	// +kubebuilder:validation:Optional
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// +kubebuilder:validation:Optional
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type IgnoredExceptionsInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomHandledException []IgnoredExceptionsCustomHandledExceptionInitParameters `json:"customHandledException,omitempty" tf:"custom_handled_exception,omitempty"`
}

type IgnoredExceptionsObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomHandledException []IgnoredExceptionsCustomHandledExceptionObservation `json:"customHandledException,omitempty" tf:"custom_handled_exception,omitempty"`
}

type IgnoredExceptionsParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CustomHandledException []IgnoredExceptionsCustomHandledExceptionParameters `json:"customHandledException" tf:"custom_handled_exception,omitempty"`
}

type SuccessForcingExceptionsCustomHandledExceptionInitParameters struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type SuccessForcingExceptionsCustomHandledExceptionObservation struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type SuccessForcingExceptionsCustomHandledExceptionParameters struct {

	// (String) The pattern will match if it is contained within the actual class name.
	// The pattern will match if it is contained within the actual class name.
	// +kubebuilder:validation:Optional
	ClassPattern *string `json:"classPattern,omitempty" tf:"class_pattern,omitempty"`

	// (String) Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
	// +kubebuilder:validation:Optional
	MessagePattern *string `json:"messagePattern,omitempty" tf:"message_pattern,omitempty"`
}

type SuccessForcingExceptionsInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomHandledException []SuccessForcingExceptionsCustomHandledExceptionInitParameters `json:"customHandledException,omitempty" tf:"custom_handled_exception,omitempty"`
}

type SuccessForcingExceptionsObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	CustomHandledException []SuccessForcingExceptionsCustomHandledExceptionObservation `json:"customHandledException,omitempty" tf:"custom_handled_exception,omitempty"`
}

type SuccessForcingExceptionsParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CustomHandledException []SuccessForcingExceptionsCustomHandledExceptionParameters `json:"customHandledException" tf:"custom_handled_exception,omitempty"`
}

// FailureDetectionParametersSpec defines the desired state of FailureDetectionParameters
type FailureDetectionParametersSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FailureDetectionParametersParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider FailureDetectionParametersInitParameters `json:"initProvider,omitempty"`
}

// FailureDetectionParametersStatus defines the observed state of FailureDetectionParameters.
type FailureDetectionParametersStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FailureDetectionParametersObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// FailureDetectionParameters is the Schema for the FailureDetectionParameterss API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type FailureDetectionParameters struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.brokenLinks) || (has(self.initProvider) && has(self.initProvider.brokenLinks))",message="spec.forProvider.brokenLinks is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.exceptionRules) || (has(self.initProvider) && has(self.initProvider.exceptionRules))",message="spec.forProvider.exceptionRules is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.httpResponseCodes) || (has(self.initProvider) && has(self.initProvider.httpResponseCodes))",message="spec.forProvider.httpResponseCodes is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   FailureDetectionParametersSpec   `json:"spec"`
	Status FailureDetectionParametersStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FailureDetectionParametersList contains a list of FailureDetectionParameterss
type FailureDetectionParametersList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []FailureDetectionParameters `json:"items"`
}

// Repository type metadata.
var (
	FailureDetectionParameters_Kind             = "FailureDetectionParameters"
	FailureDetectionParameters_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: FailureDetectionParameters_Kind}.String()
	FailureDetectionParameters_KindAPIVersion   = FailureDetectionParameters_Kind + "." + CRDGroupVersion.String()
	FailureDetectionParameters_GroupVersionKind = CRDGroupVersion.WithKind(FailureDetectionParameters_Kind)
)

func init() {
	SchemeBuilder.Register(&FailureDetectionParameters{}, &FailureDetectionParametersList{})
}

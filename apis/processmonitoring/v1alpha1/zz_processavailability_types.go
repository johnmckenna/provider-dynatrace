// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type HostMetadataConditionInitParameters struct {

	// (Boolean) When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
	// When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
	KeyMustExist *bool `json:"keyMustExist,omitempty" tf:"key_must_exist,omitempty"`

	// (String) This string has to match a required format.
	// This string has to match a required format.
	//
	// - `$contains(production)` – Matches if `production` appears anywhere in the host metadata value.
	// - `$eq(production)` – Matches if `production` matches the host metadata value exactly.
	// - `$prefix(production)` – Matches if `production` matches the prefix of the host metadata value.
	// - `$suffix(production)` – Matches if `production` matches the suffix of the host metadata value.
	//
	// Available logic operations:
	// - `$not($eq(production))` – Matches if the host metadata value is different from `production`.
	// - `$and($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` and ends with `main`.
	// - `$or($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` or ends with `main`.
	//
	// Brackets **(** and **)** that are part of the matched property **must be escaped with a tilde (~)**
	MetadataCondition *string `json:"metadataCondition,omitempty" tf:"metadata_condition,omitempty"`

	// (String) Key
	// Key
	MetadataKey *string `json:"metadataKey,omitempty" tf:"metadata_key,omitempty"`
}

type HostMetadataConditionObservation struct {

	// (Boolean) When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
	// When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
	KeyMustExist *bool `json:"keyMustExist,omitempty" tf:"key_must_exist,omitempty"`

	// (String) This string has to match a required format.
	// This string has to match a required format.
	//
	// - `$contains(production)` – Matches if `production` appears anywhere in the host metadata value.
	// - `$eq(production)` – Matches if `production` matches the host metadata value exactly.
	// - `$prefix(production)` – Matches if `production` matches the prefix of the host metadata value.
	// - `$suffix(production)` – Matches if `production` matches the suffix of the host metadata value.
	//
	// Available logic operations:
	// - `$not($eq(production))` – Matches if the host metadata value is different from `production`.
	// - `$and($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` and ends with `main`.
	// - `$or($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` or ends with `main`.
	//
	// Brackets **(** and **)** that are part of the matched property **must be escaped with a tilde (~)**
	MetadataCondition *string `json:"metadataCondition,omitempty" tf:"metadata_condition,omitempty"`

	// (String) Key
	// Key
	MetadataKey *string `json:"metadataKey,omitempty" tf:"metadata_key,omitempty"`
}

type HostMetadataConditionParameters struct {

	// (Boolean) When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
	// When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
	// +kubebuilder:validation:Optional
	KeyMustExist *bool `json:"keyMustExist,omitempty" tf:"key_must_exist,omitempty"`

	// (String) This string has to match a required format.
	// This string has to match a required format.
	//
	// - `$contains(production)` – Matches if `production` appears anywhere in the host metadata value.
	// - `$eq(production)` – Matches if `production` matches the host metadata value exactly.
	// - `$prefix(production)` – Matches if `production` matches the prefix of the host metadata value.
	// - `$suffix(production)` – Matches if `production` matches the suffix of the host metadata value.
	//
	// Available logic operations:
	// - `$not($eq(production))` – Matches if the host metadata value is different from `production`.
	// - `$and($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` and ends with `main`.
	// - `$or($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` or ends with `main`.
	//
	// Brackets **(** and **)** that are part of the matched property **must be escaped with a tilde (~)**
	// +kubebuilder:validation:Optional
	MetadataCondition *string `json:"metadataCondition" tf:"metadata_condition,omitempty"`

	// (String) Key
	// Key
	// +kubebuilder:validation:Optional
	MetadataKey *string `json:"metadataKey" tf:"metadata_key,omitempty"`
}

type ItemInitParameters struct {

	// (String) Type 'dt.' for key hints.
	// Type 'dt.' for key hints.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ItemObservation struct {

	// (String) Type 'dt.' for key hints.
	// Type 'dt.' for key hints.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) no documentation available
	// no documentation available
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ItemParameters struct {

	// (String) Type 'dt.' for key hints.
	// Type 'dt.' for key hints.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) no documentation available
	// no documentation available
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type MetadataInitParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Item []ItemInitParameters `json:"item,omitempty" tf:"item,omitempty"`
}

type MetadataObservation struct {

	// (Block Set, Min: 1) (see below for nested schema)
	Item []ItemObservation `json:"item,omitempty" tf:"item,omitempty"`
}

type MetadataParameters struct {

	// (Block Set, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Item []ItemParameters `json:"item" tf:"item,omitempty"`
}

type ProcessAvailabilityInitParameters struct {

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// value properties to be attached to the triggered event. (see below for nested schema)
	// Set of additional key-value properties to be attached to the triggered event.
	Metadata []MetadataInitParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Number) Specify a minimum number of processes matching the monitoring rule. If it's not satisfied, an alert will open.
	// Specify a minimum number of processes matching the monitoring rule. If it's not satisfied, an alert will open.
	MinimumProcesses *float64 `json:"minimumProcesses,omitempty" tf:"minimum_processes,omitempty"`

	// (String) Monitoring rule name
	// Monitoring rule name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Set of String) Select the operating systems on which the monitoring rule should be applied.
	// Select the operating systems on which the monitoring rule should be applied.
	// +listType=set
	OperatingSystem []*string `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// (Block List, Max: 1) Define process detection rules by selecting a process property and a condition. Each monitoring rule can have multiple detection rules associated with it. (see below for nested schema)
	// Define process detection rules by selecting a process property and a condition. Each monitoring rule can have multiple detection rules associated with it.
	Rules []RulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// (String) The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type ProcessAvailabilityObservation struct {

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// value properties to be attached to the triggered event. (see below for nested schema)
	// Set of additional key-value properties to be attached to the triggered event.
	Metadata []MetadataObservation `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Number) Specify a minimum number of processes matching the monitoring rule. If it's not satisfied, an alert will open.
	// Specify a minimum number of processes matching the monitoring rule. If it's not satisfied, an alert will open.
	MinimumProcesses *float64 `json:"minimumProcesses,omitempty" tf:"minimum_processes,omitempty"`

	// (String) Monitoring rule name
	// Monitoring rule name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Set of String) Select the operating systems on which the monitoring rule should be applied.
	// Select the operating systems on which the monitoring rule should be applied.
	// +listType=set
	OperatingSystem []*string `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// (Block List, Max: 1) Define process detection rules by selecting a process property and a condition. Each monitoring rule can have multiple detection rules associated with it. (see below for nested schema)
	// Define process detection rules by selecting a process property and a condition. Each monitoring rule can have multiple detection rules associated with it.
	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`

	// (String) The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type ProcessAvailabilityParameters struct {

	// (Boolean) This setting is enabled (true) or disabled (false)
	// This setting is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	// +kubebuilder:validation:Optional
	InsertAfter *string `json:"insertAfter,omitempty" tf:"insert_after,omitempty"`

	// value properties to be attached to the triggered event. (see below for nested schema)
	// Set of additional key-value properties to be attached to the triggered event.
	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Number) Specify a minimum number of processes matching the monitoring rule. If it's not satisfied, an alert will open.
	// Specify a minimum number of processes matching the monitoring rule. If it's not satisfied, an alert will open.
	// +kubebuilder:validation:Optional
	MinimumProcesses *float64 `json:"minimumProcesses,omitempty" tf:"minimum_processes,omitempty"`

	// (String) Monitoring rule name
	// Monitoring rule name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Set of String) Select the operating systems on which the monitoring rule should be applied.
	// Select the operating systems on which the monitoring rule should be applied.
	// +kubebuilder:validation:Optional
	// +listType=set
	OperatingSystem []*string `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// (Block List, Max: 1) Define process detection rules by selecting a process property and a condition. Each monitoring rule can have multiple detection rules associated with it. (see below for nested schema)
	// Define process detection rules by selecting a process property and a condition. Each monitoring rule can have multiple detection rules associated with it.
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// (String) The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type RuleInitParameters struct {

	// $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
	// - $prefix(svc) – Matches if app matches the prefix of the process property value.
	// - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
	//
	// For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
	//
	// For more details, see [Process availability](https://dt-url.net/v923x37).
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// defined key-value pairs that you can assign to hosts monitored by Dynatrace.
	// Host custom metadata refers to user-defined key-value pairs that you can assign to hosts monitored by Dynatrace.
	//
	// By defining custom metadata, you can enrich the monitoring data with context specific to your organization's needs, such as environment names, team ownership, application versions, or any other relevant details.
	//
	// See [Define tags and metadata for hosts](https://dt-url.net/w3hv0kbw).
	HostMetadataCondition []HostMetadataConditionInitParameters `json:"hostMetadataCondition,omitempty" tf:"host_metadata_condition,omitempty"`

	// (String) Possible Values: CommandLine, Executable, ExecutablePath, User
	// Possible Values: `CommandLine`, `Executable`, `ExecutablePath`, `User`
	Property *string `json:"property,omitempty" tf:"property,omitempty"`

	// (String) Possible Values: RuleTypeHost, RuleTypeProcess
	// Possible Values: `RuleTypeHost`, `RuleTypeProcess`
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`
}

type RuleObservation struct {

	// $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
	// - $prefix(svc) – Matches if app matches the prefix of the process property value.
	// - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
	//
	// For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
	//
	// For more details, see [Process availability](https://dt-url.net/v923x37).
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// defined key-value pairs that you can assign to hosts monitored by Dynatrace.
	// Host custom metadata refers to user-defined key-value pairs that you can assign to hosts monitored by Dynatrace.
	//
	// By defining custom metadata, you can enrich the monitoring data with context specific to your organization's needs, such as environment names, team ownership, application versions, or any other relevant details.
	//
	// See [Define tags and metadata for hosts](https://dt-url.net/w3hv0kbw).
	HostMetadataCondition []HostMetadataConditionObservation `json:"hostMetadataCondition,omitempty" tf:"host_metadata_condition,omitempty"`

	// (String) Possible Values: CommandLine, Executable, ExecutablePath, User
	// Possible Values: `CommandLine`, `Executable`, `ExecutablePath`, `User`
	Property *string `json:"property,omitempty" tf:"property,omitempty"`

	// (String) Possible Values: RuleTypeHost, RuleTypeProcess
	// Possible Values: `RuleTypeHost`, `RuleTypeProcess`
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`
}

type RuleParameters struct {

	// $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $contains(svc) – Matches if svc appears anywhere in the process property value.
	// - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
	// - $prefix(svc) – Matches if app matches the prefix of the process property value.
	// - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
	//
	// For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
	//
	// For more details, see [Process availability](https://dt-url.net/v923x37).
	// +kubebuilder:validation:Optional
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// defined key-value pairs that you can assign to hosts monitored by Dynatrace.
	// Host custom metadata refers to user-defined key-value pairs that you can assign to hosts monitored by Dynatrace.
	//
	// By defining custom metadata, you can enrich the monitoring data with context specific to your organization's needs, such as environment names, team ownership, application versions, or any other relevant details.
	//
	// See [Define tags and metadata for hosts](https://dt-url.net/w3hv0kbw).
	// +kubebuilder:validation:Optional
	HostMetadataCondition []HostMetadataConditionParameters `json:"hostMetadataCondition,omitempty" tf:"host_metadata_condition,omitempty"`

	// (String) Possible Values: CommandLine, Executable, ExecutablePath, User
	// Possible Values: `CommandLine`, `Executable`, `ExecutablePath`, `User`
	// +kubebuilder:validation:Optional
	Property *string `json:"property,omitempty" tf:"property,omitempty"`

	// (String) Possible Values: RuleTypeHost, RuleTypeProcess
	// Possible Values: `RuleTypeHost`, `RuleTypeProcess`
	// +kubebuilder:validation:Optional
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`
}

type RulesInitParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	Rule []RuleInitParameters `json:"rule,omitempty" tf:"rule,omitempty"`
}

type RulesObservation struct {

	// (Block List, Min: 1) (see below for nested schema)
	Rule []RuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`
}

type RulesParameters struct {

	// (Block List, Min: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule" tf:"rule,omitempty"`
}

// ProcessAvailabilitySpec defines the desired state of ProcessAvailability
type ProcessAvailabilitySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ProcessAvailabilityParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ProcessAvailabilityInitParameters `json:"initProvider,omitempty"`
}

// ProcessAvailabilityStatus defines the observed state of ProcessAvailability.
type ProcessAvailabilityStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ProcessAvailabilityObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ProcessAvailability is the Schema for the ProcessAvailabilitys API. The resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatrace}
type ProcessAvailability struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enabled) || (has(self.initProvider) && has(self.initProvider.enabled))",message="spec.forProvider.enabled is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ProcessAvailabilitySpec   `json:"spec"`
	Status ProcessAvailabilityStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ProcessAvailabilityList contains a list of ProcessAvailabilitys
type ProcessAvailabilityList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProcessAvailability `json:"items"`
}

// Repository type metadata.
var (
	ProcessAvailability_Kind             = "ProcessAvailability"
	ProcessAvailability_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ProcessAvailability_Kind}.String()
	ProcessAvailability_KindAPIVersion   = ProcessAvailability_Kind + "." + CRDGroupVersion.String()
	ProcessAvailability_GroupVersionKind = CRDGroupVersion.WithKind(ProcessAvailability_Kind)
)

func init() {
	SchemeBuilder.Register(&ProcessAvailability{}, &ProcessAvailabilityList{})
}
